<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>highlight.js在Vue3项目中使用的一些经验总结</title>
      <link href="/2025/04/06/highlight-learning/"/>
      <url>/2025/04/06/highlight-learning/</url>
      
        <content type="html"><![CDATA[<p>官方文档内容不是非常详细，因此将我在Vue3项目中使用highlight的过程做一个记录。</p><hr><p>使用highlight.js需要引入必需部分：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> hljs <span class="keyword">from</span> <span class="string">&#x27;highlight.js&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;highlight.js/styles/github.css&#x27;</span>; <span class="comment">// 代码高亮样式，种类比较丰富，这里选择github样式</span></span><br></pre></td></tr></table></figure><p>我这个项目里面，利用下面的方式获取需要高亮的代码块引用。其中，<code>&lt;pre&gt;&lt;code&gt;</code>是官方推荐的包裹代码块的方法。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">pre</span>&gt;</span><span class="tag">&lt;<span class="name">code</span> <span class="attr">ref</span>=<span class="string">&quot;cleanCode&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">code</span>&gt;</span><span class="tag">&lt;/<span class="name">pre</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> cleanCode = ref&lt;<span class="title class_">HTMLElement</span> | <span class="literal">null</span>&gt;(<span class="literal">null</span>);</span><br></pre></td></tr></table></figure><p>我的代码内容是变化的，所以<code>&lt;pre&gt;&lt;code&gt;</code>中包裹的内容需要使用cleanCode的innerHtml动态指定。</p><p>也因此，不能通过下面这种方式指定代码语言：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">pre</span>&gt;</span><span class="tag">&lt;<span class="name">code</span> <span class="attr">class</span>=<span class="string">&quot;language-html&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">code</span>&gt;</span><span class="tag">&lt;/<span class="name">pre</span>&gt;</span></span><br></pre></td></tr></table></figure><hr><p>代码高亮有几种方式：</p><p><strong>1、highlightAll()</strong></p><p>这种方法检测页面上所有<code>&lt;pre&gt;&lt;code&gt;</code>标签，并根据其class中指定的语言类型进行高亮显示。注意这种方法必须指定语言，否则控制台会出现下面的报错：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Could not find the language &#x27;undefined&#x27;, did you forget to load/include a language module?</span><br></pre></td></tr></table></figure><p>根据官网文档，作用域为一个页面，但在vue组件中，我怀疑可能作用域只局限于单个组件内。这里我没有做相关实验。</p><p><strong>2、highlightElement()</strong></p><p>接受一个HTMLElement作为参数，高亮其中代码。</p><p>用法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> clean = <span class="title function_">ref</span>(<span class="string">`</span></span><br><span class="line"><span class="string">function helloWorld() &#123;</span></span><br><span class="line"><span class="string">console.log(&#x27;Hello, World!&#x27;);</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">`</span>); <span class="comment">// 动态变化的代码</span></span><br><span class="line"></span><br><span class="line">cleanCode.<span class="property">value</span>.<span class="property">innerHTML</span> = clean.<span class="property">value</span></span><br><span class="line"><span class="keyword">const</span> lang = <span class="title function_">getLanguage</span>(clean.<span class="property">value</span>) <span class="comment">// 自己写的函数，用于区分代码语言</span></span><br><span class="line">cleanCode.<span class="property">value</span>.<span class="property">className</span> = <span class="string">`language-<span class="subst">$&#123;lang&#125;</span>`</span> <span class="comment">// 动态修改className</span></span><br><span class="line"><span class="keyword">if</span>(cleanCode.<span class="property">value</span>.<span class="property">dataset</span>.<span class="property">highlighted</span>) &#123;</span><br><span class="line">    <span class="keyword">delete</span> cleanCode.<span class="property">value</span>.<span class="property">dataset</span>.<span class="property">highlighted</span></span><br><span class="line">&#125;</span><br><span class="line">hljs.<span class="title function_">highlightElement</span>(cleanCode.<span class="property">value</span>)</span><br></pre></td></tr></table></figure><p>需要注意，已经被高亮的代码块，highlight.js会给一个highlighted标记，并拒绝再次高亮。如果其中内容发生变动需要重新高亮，此时必须清除掉其中的标记：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(cleanCode.<span class="property">value</span>.<span class="property">dataset</span>.<span class="property">highlighted</span>) &#123;</span><br><span class="line">    <span class="keyword">delete</span> cleanCode.<span class="property">value</span>.<span class="property">dataset</span>.<span class="property">highlighted</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3、highlightAuto()</strong></p><p>接受一个code字符串作为参数，返回高亮后的html字符串。这个函数能够自动判别代码语言，不需要指定className，但我实测下来并不准确。</p><p>用法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(cleanCode.<span class="property">value</span>.<span class="property">dataset</span>.<span class="property">highlighted</span>) &#123;</span><br><span class="line">    <span class="keyword">delete</span> cleanCode.<span class="property">value</span>.<span class="property">dataset</span>.<span class="property">highlighted</span></span><br><span class="line">&#125;</span><br><span class="line">cleanCode.<span class="property">value</span>.<span class="property">innerHTML</span> = hljs.<span class="title function_">highlightAuto</span>(clean.<span class="property">value</span>).<span class="property">value</span></span><br></pre></td></tr></table></figure><p>结果如下，明显不准确：</p><img src="https://shingeki-pic.oss-cn-nanjing.aliyuncs.com/img/20250407000121574.png" style="zoom:80%;" ><p>如果在第二个参数中指定可能的语言类型，高亮结果会更加准确。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cleanCode.<span class="property">value</span>.<span class="property">innerHTML</span> = hljs.<span class="title function_">highlightAuto</span>(clean.<span class="property">value</span>, [<span class="string">&#x27;cpp&#x27;</span>, <span class="string">&#x27;java&#x27;</span>, <span class="string">&#x27;python&#x27;</span>]).<span class="property">value</span></span><br></pre></td></tr></table></figure><p>结果：<br><img src="https://shingeki-pic.oss-cn-nanjing.aliyuncs.com/img/20250406235926293.png" style="zoom: 80%;" /></p><hr><p>下面这段是官方文档上给的vue中highlight.js的用法，但我没有试过：</p><blockquote><p>下载 <a href="https://github.com/highlightjs/vue-plugin">highlightjs&#x2F;vue-plugin</a>，这是用 <code>highlight.js</code> 封装好的 <code>vue</code> 插件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;highlightjs</span><br><span class="line">    language=&quot;js&quot;</span><br><span class="line">    code=&quot;console.log(&#x27;Hello World&#x27;);&quot;</span><br><span class="line">  /&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import &#x27;highlight.js/lib/common&#x27;;</span><br><span class="line">import hljsVuePlugin from &quot;@highlightjs/vue-plugin&quot;;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    highlightjs: hljsVuePlugin.component</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></blockquote>]]></content>
      
      
      <categories>
          
          <category> 经验总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
            <tag> vue3 </tag>
            
            <tag> highlight.js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件安全课程报告汇总</title>
      <link href="/2025/04/03/software-safety-reports/"/>
      <url>/2025/04/03/software-safety-reports/</url>
      
        <content type="html"><![CDATA[<h1 id="DVWA实验"><a href="#DVWA实验" class="headerlink" title="DVWA实验"></a>DVWA实验</h1><h2 id="一、DVWA安装配置"><a href="#一、DVWA安装配置" class="headerlink" title="一、DVWA安装配置"></a>一、DVWA安装配置</h2><p>这一部分参考博客<a href="https://blog.csdn.net/qq_41705207/article/details/109579027">https://blog.csdn.net/qq_41705207/article/details/109579027</a></p><p>1 在github上获取DVWA，具体地址为<a href="https://github.com/digininja/DVWA/releases">https://github.com/digininja/DVWA/releases</a></p><p>2 利用phpstudy启动DVWA，将DVWA存入指定目录。</p><p><img src="https://shingeki-pic.oss-cn-nanjing.aliyuncs.com/img/20250403232806883.png"></p><p>3 启动phpstudy，开启Apache，同时发现Mysql与本机上服务冲突无法启动，直接利用本机服务即可。</p><img src="https://shingeki-pic.oss-cn-nanjing.aliyuncs.com/img/20250403232900762.png" style="zoom:67%;" /><p>4 修改DVWA配置，使得其与本机mysql配置一致。</p><img src="https://shingeki-pic.oss-cn-nanjing.aliyuncs.com/img/20250403233140308.png" style="zoom:80%;" /><p>5 输入地址<a href="http://127.0.0.1/DVWA-2.4%EF%BC%8C%E5%BC%80%E5%A7%8B%E9%85%8D%E7%BD%AEDVWA%E3%80%82">http://127.0.0.1/DVWA-2.4，开始配置DVWA。</a></p><img src="https://shingeki-pic.oss-cn-nanjing.aliyuncs.com/img/20250403233227691.png" alt="image-20250105133642702" style="zoom: 50%;" /><p>6 发现配置中出现两个错误。</p><img src="https://shingeki-pic.oss-cn-nanjing.aliyuncs.com/img/20250403233231052.png" alt="image-20250105133934986" style="zoom:67%;" /><p>7 对于第一个错误，找到phpstudy中对应配置文件进行修改。</p><img src="https://shingeki-pic.oss-cn-nanjing.aliyuncs.com/img/20250403233237389.png" alt="image-20250105134154616" style="zoom:50%;" /><p>8 对于第二个错误，找到dvwa配置文件中有关部分修改。</p><img src="https://shingeki-pic.oss-cn-nanjing.aliyuncs.com/img/20250403233240239.png" alt="image-20250105134627215" style="zoom:67%;" /><p>9 重启phpstudy后发现错误已经修正。</p><img src="https://shingeki-pic.oss-cn-nanjing.aliyuncs.com/img/20250403233242914.png" alt="image-20250105134713874" style="zoom:50%;" /><p>10 创建数据库后即可登录DVWA。</p><img src="https://shingeki-pic.oss-cn-nanjing.aliyuncs.com/img/20250403233246356.png" alt="image-20250105134955078" style="zoom:67%;" /><h2 id="二、利用Seay进行源代码审查"><a href="#二、利用Seay进行源代码审查" class="headerlink" title="二、利用Seay进行源代码审查"></a>二、利用Seay进行源代码审查</h2><p>1 新建项目，选择DVWA。</p><img src="https://shingeki-pic.oss-cn-nanjing.aliyuncs.com/img/20250403233250210.png" alt="image-20250105153918077" style="zoom: 50%;" /><p>2 利用自动审计扫描漏洞，一共发现61个漏洞。针对每个漏洞给出了漏洞描述、文件路径以及详细代码位置。</p><p><img src="https://shingeki-pic.oss-cn-nanjing.aliyuncs.com/img/20250403233255375.png" alt="image-20250105154102998"></p><img src="https://shingeki-pic.oss-cn-nanjing.aliyuncs.com/img/20250403233300670.png" alt="image-20250105154247510" style="zoom:67%;" /><h2 id="三、利用RIPS进行源代码审查"><a href="#三、利用RIPS进行源代码审查" class="headerlink" title="三、利用RIPS进行源代码审查"></a>三、利用RIPS进行源代码审查</h2><p>1 在网络上获取RIPS，具体地址为 <a href="https://sourceforge.net/projects/rips-scanner/files/latest/download">https://sourceforge.net/projects/rips-scanner/files/latest/download</a> ，并解压到phpstudy的指定目录下，即与DVWA同级别。</p><img src="https://shingeki-pic.oss-cn-nanjing.aliyuncs.com/img/20250403233304201.png" alt="image-20250105155107307" style="zoom: 67%;" /><p>2 输入地址<a href="http://127.0.0.1/rips-0.55/%EF%BC%8C%E8%BF%9B%E5%85%A5RIPS">http://127.0.0.1/rips-0.55/，进入RIPS</a></p><img src="https://shingeki-pic.oss-cn-nanjing.aliyuncs.com/img/20250403233307227.png" alt="image-20250105155231162" style="zoom:50%;" /><p>3 输入DVWA的地址，进行扫描，一共检出39个漏洞。RIPS对这些漏洞的类型进行了分类。RIPS同样给出了漏洞的具体位置。</p><img src="https://shingeki-pic.oss-cn-nanjing.aliyuncs.com/img/20250403233311682.png" alt="image-20250105155726981" style="zoom:50%;" /><h2 id="四、利用CodeXploiter进行源代码审查"><a href="#四、利用CodeXploiter进行源代码审查" class="headerlink" title="四、利用CodeXploiter进行源代码审查"></a>四、利用CodeXploiter进行源代码审查</h2><p>选择DVWA中的php文件，扫描后共发现与文件获取、SQL注入有关的三个漏洞。展开可以看到更详细的信息。</p><img src="https://shingeki-pic.oss-cn-nanjing.aliyuncs.com/img/20250403233316143.png" alt="image-20250105160403185" style="zoom:67%;" /><img src="https://shingeki-pic.oss-cn-nanjing.aliyuncs.com/img/20250403233320254.png" alt="image-20250105160621393" style="zoom:67%;" /><h2 id="五、工具对比"><a href="#五、工具对比" class="headerlink" title="五、工具对比"></a>五、工具对比</h2><p>Seay检出的漏洞明显多于另外两种工具；但其检查所需时间也更长。</p><p>CodeXploiter检出的漏洞过少，可能并不可靠；Seay检出漏洞多，但也有误报可能。</p><p>Seay对于漏洞位置的描述最为详细，RIPS次之，CodeXploiter最粗略。</p><hr><h1 id="AFL实验报告"><a href="#AFL实验报告" class="headerlink" title="AFL实验报告"></a>AFL实验报告</h1><p>本实验利用**AFL (American Fuzzy Lop)**针对一段C语言代码进行模糊测试。</p><p>部分步骤参考博客<a href="https://blog.csdn.net/weixin_45100742/article/details/134177614">https://blog.csdn.net/weixin_45100742/article/details/134177614</a></p><h2 id="一、环境准备"><a href="#一、环境准备" class="headerlink" title="一、环境准备"></a>一、环境准备</h2><p>虚拟机上已经提前安装好<strong>make、gcc</strong>等依赖。</p><p>1 从github上（  <a href="https://github.com/google/AFL/releases/tag/v2.57b">https://github.com/google/AFL/releases/tag/v2.57b</a>  ）获取AFL源代码，解压到本地。</p><img src="https://shingeki-pic.oss-cn-nanjing.aliyuncs.com/img/20250403233701332.png" alt="image-20250105203354367" style="zoom:67%;" /><p>2 随后运行<strong>make install</strong>命令，AFL已经安装好。</p><img src="https://shingeki-pic.oss-cn-nanjing.aliyuncs.com/img/20250404121411102.png" alt="image-20250105203509397" style="zoom:67%;" /><h2 id="二、C程序准备"><a href="#二、C程序准备" class="headerlink" title="二、C程序准备"></a>二、C程序准备</h2><p>1 网络上寻找一段可能出错的程序：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 功能：两数加减乘除（一个整数、一个字符、再一个整数），然后根据中间这个字符当作运算符，输出四则运算结果。 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a, b;</span><br><span class="line">    <span class="type">char</span> op;</span><br><span class="line">    <span class="type">int</span> result;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d%c%d&quot;</span>, &amp;a, &amp;op, &amp;b))&#123;</span><br><span class="line">        <span class="keyword">switch</span> (op) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">                result = a + b;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">                result = a - b;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">                result = a * b;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">                result = a / b;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, result);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2 构建模糊测试种子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &#x27;1+2&#x27; &gt; seeds/seed1</span><br></pre></td></tr></table></figure><p>3 利用AFL编译程序：</p><img src="https://shingeki-pic.oss-cn-nanjing.aliyuncs.com/img/20250403233705159.png" alt="image-20250105205629593" style="zoom:67%;" /><h2 id="三、测试"><a href="#三、测试" class="headerlink" title="三、测试"></a>三、测试</h2><p>1 运行命令 <strong>afl-fuzz -i seeds&#x2F; -o fuzz_output .&#x2F;test</strong> ，开始测试，出现报错</p><img src="https://shingeki-pic.oss-cn-nanjing.aliyuncs.com/img/20250403233709265.png" alt="image-20250105235911716" style="zoom:67%;" /><p>2 阅读报错信息发现，获取权限后，执行给出的 <strong>echo core &gt;&#x2F;proc&#x2F;sys&#x2F;kernel&#x2F;core_pattern</strong> 命令即可解决。</p><img src="https://shingeki-pic.oss-cn-nanjing.aliyuncs.com/img/20250403233714801.png" alt="image-20250106002500719" style="zoom:67%;" /><p>3 ctrl+c，主动结束测试。</p><img src="https://shingeki-pic.oss-cn-nanjing.aliyuncs.com/img/20250403233719190.png" alt="image-20250106002543273" style="zoom:67%;" /><h2 id="四、结果分析"><a href="#四、结果分析" class="headerlink" title="四、结果分析"></a>四、结果分析</h2><p>由上图可知，测试过程中出现了一个崩溃，并没有发生超时。</p><p>以下是AFL测试的输出结果：</p><img src="https://shingeki-pic.oss-cn-nanjing.aliyuncs.com/img/20250403233725470.png" alt="image-20250106110411955" style="zoom: 67%;" /><p>其中crashes中是导致崩溃的测试用例，hangs中是代表超时的测试用例。</p><p>打开crashes文件夹，发现一个导致崩溃的测试用例为1&#x2F;0，此时发生除零异常。而hangs文件夹为空。</p><img src="https://shingeki-pic.oss-cn-nanjing.aliyuncs.com/img/20250403233729565.png" alt="image-20250106110553292" style="zoom:67%;" /><p>测试发现1&#x2F;0确实会导致错误。</p><img src="https://shingeki-pic.oss-cn-nanjing.aliyuncs.com/img/20250403233732508.png" alt="image-20250106110858686" style="zoom:67%;" /><p>由于C语言代码的原因，这段代码只可能出现崩溃，不可能超时，测试中也不会找到导致超时的用例。</p><hr><h1 id="Metasploit漏洞测试实验"><a href="#Metasploit漏洞测试实验" class="headerlink" title="Metasploit漏洞测试实验"></a>Metasploit漏洞测试实验</h1><h2 id="一、kali系统准备"><a href="#一、kali系统准备" class="headerlink" title="一、kali系统准备"></a>一、kali系统准备</h2><p>在 <a href="https://www.kali.org/get-kali/#kali-installer-images">https://www.kali.org/get-kali/#kali-installer-images</a> 上获取镜像，在VMware上安装</p><p>安装过程没有截图，大部分按照默认设置。</p><img src="https://shingeki-pic.oss-cn-nanjing.aliyuncs.com/img/20250403233854890.png" alt="image-20250106123159236" style="zoom: 33%;" /><h2 id="二、初始化并启动Metasploit"><a href="#二、初始化并启动Metasploit" class="headerlink" title="二、初始化并启动Metasploit"></a>二、初始化并启动Metasploit</h2><p>1 执行命令<strong>service postgresql start</strong>，启动postgresql，查看状态。</p><img src="https://shingeki-pic.oss-cn-nanjing.aliyuncs.com/img/20250403233858910.png" alt="image-20250106160735460" style="zoom: 80%;" /><p>2 初始化数据库。</p><img src="https://shingeki-pic.oss-cn-nanjing.aliyuncs.com/img/20250403233903826.png" alt="image-20250106160928525" style="zoom:80%;" /><p>3 进入msf框架。</p><img src="https://shingeki-pic.oss-cn-nanjing.aliyuncs.com/img/20250403233907310.png" alt="image-20250106161047394" style="zoom:67%;" /><h2 id="三、挖掘MS08-067漏洞"><a href="#三、挖掘MS08-067漏洞" class="headerlink" title="三、挖掘MS08-067漏洞"></a>三、挖掘MS08-067漏洞</h2><p>1 受害机选择Windows XP Service Pack 2</p><img src="https://shingeki-pic.oss-cn-nanjing.aliyuncs.com/img/20250403233910178.png" alt="image-20250106161929802" style="zoom: 80%;" /><p>2 关闭windows的防火墙</p><img src="https://shingeki-pic.oss-cn-nanjing.aliyuncs.com/img/20250403233914150.png" alt="image-20250106164851996" style="zoom:67%;" /><p>3 获取kali机器和windows机器的ip地址，得到kali的ip为192.168.11.130，windows的ip为192.168.11.128</p><img src="https://shingeki-pic.oss-cn-nanjing.aliyuncs.com/img/20250403233916813.png" alt="image-20250106164258153" style="zoom:80%;" /><img src="https://shingeki-pic.oss-cn-nanjing.aliyuncs.com/img/20250403233923966.png" alt="image-20250106164347279" style="zoom: 80%;" /><p>4 两者互相可以ping通。</p><img src="https://shingeki-pic.oss-cn-nanjing.aliyuncs.com/img/20250403233919235.png" alt="image-20250106165620257" style="zoom:67%;" /><img src="https://shingeki-pic.oss-cn-nanjing.aliyuncs.com/img/20250403233934923.png" alt="image-20250106165654498" style="zoom:67%;" /><p>5 查看windows系统中445端口状态，发现已经开启</p><img src="https://shingeki-pic.oss-cn-nanjing.aliyuncs.com/img/20250403233942128.png" alt="image-20250106164729064" style="zoom:80%;" /><p>6 在kali上利用nmap发现windows的445端口对外开放</p><img src="https://shingeki-pic.oss-cn-nanjing.aliyuncs.com/img/20250403233946721.png" alt="image-20250106171643505" style="zoom:67%;" /><p>7 在msf控制台中搜索ms08-067，找到一个对应模块</p><p><img src="https://shingeki-pic.oss-cn-nanjing.aliyuncs.com/img/20250403233952143.png" alt="image-20250106172004799"></p><p>8 查看配置与目标</p><img src="https://shingeki-pic.oss-cn-nanjing.aliyuncs.com/img/20250403233956185.png" alt="image-20250106172702050" style="zoom:67%;" /><img src="https://shingeki-pic.oss-cn-nanjing.aliyuncs.com/img/20250403234002473.png" alt="image-20250106172724932" style="zoom:67%;" /><p>9 设置两台机器的信息。</p><p><img src="https://shingeki-pic.oss-cn-nanjing.aliyuncs.com/img/20250403234045369.png" alt="image-20250106174131811"></p><img src="https://shingeki-pic.oss-cn-nanjing.aliyuncs.com/img/20250403234048803.png" alt="image-20250106174332864" style="zoom:80%;" /><p>根据上面show targets中给出的信息 配置target为对应xp系统版本</p><img src="https://shingeki-pic.oss-cn-nanjing.aliyuncs.com/img/20250403234052206.png" alt="image-20250106174513328" style="zoom:80%;" /><p>10 执行exploit</p><img src="https://shingeki-pic.oss-cn-nanjing.aliyuncs.com/img/20250403234101352.png" alt="image-20250106175726187" style="zoom:67%;" /><p>11 执行ipconfig sysinfo，可以看到xp系统的详细信息。</p><img src="https://shingeki-pic.oss-cn-nanjing.aliyuncs.com/img/20250403234105699.png" alt="image-20250106175818110" style="zoom:67%;" /><p>12 在kali上，在windows的C盘中新建一个hack文件夹</p><img src="https://shingeki-pic.oss-cn-nanjing.aliyuncs.com/img/20250403234109121.png" alt="image-20250106180038160" style="zoom:80%;" /><p>13 在windows虚拟机上发现多了一个hack文件夹。</p><img src="https://shingeki-pic.oss-cn-nanjing.aliyuncs.com/img/20250403234113317.png" alt="image-20250106191335454" style="zoom:67%;" /><hr><h1 id="Crackme破解实验"><a href="#Crackme破解实验" class="headerlink" title="Crackme破解实验"></a>Crackme破解实验</h1><p>实验选择160个程序中的第一个。</p><h2 id="一、前期准备"><a href="#一、前期准备" class="headerlink" title="一、前期准备"></a>一、前期准备</h2><p>在网络上下载吾爱破解版本的OllyDbg，并下载160个Crackme程序中的第一个。</p><img src="https://shingeki-pic.oss-cn-nanjing.aliyuncs.com/img/20250403234243749.png" alt="image-20250108220438131" style="zoom: 50%;" /><h2 id="二、程序逻辑观察"><a href="#二、程序逻辑观察" class="headerlink" title="二、程序逻辑观察"></a>二、程序逻辑观察</h2><p>打开程序，观察其运行大概过程。</p><img src="https://shingeki-pic.oss-cn-nanjing.aliyuncs.com/img/20250403234246745.png" alt="image-20250108215231122" style="zoom:67%;" /><p>点击第一个按钮，出现界面：</p><img src="https://shingeki-pic.oss-cn-nanjing.aliyuncs.com/img/20250403234249976.png" alt="image-20250108215322083" style="zoom:67%;" /><p>点击第一个按钮出现如下报错，点击第二个按钮返回。</p><img src="https://shingeki-pic.oss-cn-nanjing.aliyuncs.com/img/20250403234252724.png" alt="image-20250108215339685" style="zoom:67%;" /><p>点击主页第三个按钮，出现界面：</p><img src="https://shingeki-pic.oss-cn-nanjing.aliyuncs.com/img/20250403234255445.png" alt="image-20250108215426466" style="zoom:67%;" /><p>点击第一个按钮出现如下报错，点击第二个按钮返回。</p><img src="https://shingeki-pic.oss-cn-nanjing.aliyuncs.com/img/20250403234257940.png" alt="image-20250108215456982" style="zoom:67%;" /><h2 id="三、程序破解"><a href="#三、程序破解" class="headerlink" title="三、程序破解"></a>三、程序破解</h2><p>这次实验以Serial&#x2F;Name部分为例。</p><img src="https://shingeki-pic.oss-cn-nanjing.aliyuncs.com/img/20250403234300469.png" alt="image-20250108215339685" style="zoom:67%;" /><p>这里是弹窗报错，判断对错的代码应该就在弹窗代码附近。在ollydbg中，查找相应字符串：</p><img src="https://shingeki-pic.oss-cn-nanjing.aliyuncs.com/img/20250403234304378.png" alt="image-20250108220855538" style="zoom:67%;" /><p>定位到程序中：</p><img src="https://shingeki-pic.oss-cn-nanjing.aliyuncs.com/img/20250403234307020.png" alt="image-20250108220921866" style="zoom:67%;" /><p>附近的代码0042FB07H 和 0042FB0CH中，引用的数据为：</p><p><img src="https://shingeki-pic.oss-cn-nanjing.aliyuncs.com/img/20250403234310879.png" alt="image-20250108221123793"></p><p>这是代表成功的弹窗。</p><p>因此将0042FB03的jnz跳转语句修改为nop，不执行跳转，此时就会触发成功的弹窗。</p><img src="https://shingeki-pic.oss-cn-nanjing.aliyuncs.com/img/20250403234313282.png" alt="image-20250108221333083" style="zoom:67%;" /><p>将修改保存到另一个文件：</p><img src="https://shingeki-pic.oss-cn-nanjing.aliyuncs.com/img/20250403234316283.png" alt="image-20250108221417212" style="zoom:67%;" /><img src="https://shingeki-pic.oss-cn-nanjing.aliyuncs.com/img/20250403234318604.png" alt="image-20250108221450417" style="zoom:67%;" /><p>打开新的文件，发现出现了成功弹窗，绕过了判断。</p><img src="https://shingeki-pic.oss-cn-nanjing.aliyuncs.com/img/20250403234321366.png" alt="image-20250108221540306" style="zoom:67%;" /><h2 id="四、注册机编写"><a href="#四、注册机编写" class="headerlink" title="四、注册机编写"></a>四、注册机编写</h2><p>这里我发现中文翻译版似乎存在bug，点击运行后程序的窗口不会跳出来，因此后续用英文版。</p><p>在上面发现的关键位置打上断点，程序运行到该位置：</p><p><img src="https://shingeki-pic.oss-cn-nanjing.aliyuncs.com/img/20250403234324154.png" alt="image-20250108225216727"></p><p>查看寄存器状态，发现EAX中可能为正确的序列号。</p><p><img src="https://shingeki-pic.oss-cn-nanjing.aliyuncs.com/img/20250403234327422.png" alt="image-20250108225249786"></p><p>输入后发现正确。</p><img src="https://shingeki-pic.oss-cn-nanjing.aliyuncs.com/img/20250403234330197.png" alt="image-20250108230336595" style="zoom:67%;" /><p>但修改第一个输入框中的名字，同样的序列号则出错。</p><img src="https://shingeki-pic.oss-cn-nanjing.aliyuncs.com/img/20250403234332739.png" alt="image-20250108230424907" style="zoom:67%;" /><p>代码中有两处相同的报错信息“Sorry…”，说明可能存在不同的出错原因。阅读代码发现原因在于长度小于4的名字会被直接判错。</p><img src="https://shingeki-pic.oss-cn-nanjing.aliyuncs.com/img/20250403234335067.png" alt="image-20250108234334017" style="zoom:67%;" /><p>换一个输入，发现正确的序列号发生了变化，且只有中间的四个数字变化。</p><img src="https://shingeki-pic.oss-cn-nanjing.aliyuncs.com/img/20250403234337384.png" alt="image-20250108234944374" style="zoom:67%;" /><p><img src="https://shingeki-pic.oss-cn-nanjing.aliyuncs.com/img/20250403234339680.png" alt="image-20250108234846889"></p><p>接下来这一段代码中出现了两个“-”，说明这里可能实现的是拼接字符串的逻辑。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">0042FA7C  |.  8B83 DC010000 mov eax,dword ptr ds:[ebx+0x1DC]</span><br><span class="line">0042FA82  |.  E8 D1AFFEFF   call Acid_bur.0041AA58</span><br><span class="line">0042FA87  |.  8B45 F0       mov eax,[local.4]</span><br><span class="line">0042FA8A  |.  0FB600        movzx eax,byte ptr ds:[eax]</span><br><span class="line">0042FA8D  |.  F72D 50174300 imul dword ptr ds:[0x431750]</span><br><span class="line">0042FA93  |.  A3 50174300   mov dword ptr ds:[0x431750],eax</span><br><span class="line">0042FA98  |.  A1 50174300   mov eax,dword ptr ds:[0x431750]</span><br><span class="line">0042FA9D  |.  0105 50174300 add dword ptr ds:[0x431750],eax</span><br><span class="line">0042FAA3  |.  8D45 FC       lea eax,[local.1]</span><br><span class="line">0042FAA6  |.  BA ACFB4200   mov edx,Acid_bur.0042FBAC</span><br><span class="line">0042FAAB  |.  E8 583CFDFF   call Acid_bur.00403708</span><br><span class="line">0042FAB0  |.  8D45 F8       lea eax,[local.2]</span><br><span class="line">0042FAB3  |.  BA B8FB4200   mov edx,Acid_bur.0042FBB8</span><br><span class="line">0042FAB8  |.  E8 4B3CFDFF   call Acid_bur.00403708</span><br><span class="line">0042FABD  |.  FF75 FC       push [local.1]                           ;  kernel32.BaseThreadInitThunk</span><br><span class="line">0042FAC0  |.  68 C8FB4200   push Acid_bur.0042FBC8                   ;  UNICODE &quot;-&quot;</span><br><span class="line">0042FAC5  |.  8D55 E8       lea edx,[local.6]</span><br><span class="line">0042FAC8  |.  A1 50174300   mov eax,dword ptr ds:[0x431750]</span><br><span class="line">0042FACD  |.  E8 466CFDFF   call Acid_bur.00406718</span><br><span class="line">0042FAD2  |.  FF75 E8       push [local.6]</span><br><span class="line">0042FAD5  |.  68 C8FB4200   push Acid_bur.0042FBC8                   ;  UNICODE &quot;-&quot;</span><br><span class="line">0042FADA  |.  FF75 F8       push [local.2]</span><br><span class="line">0042FADD  |.  8D45 F4       lea eax,[local.3]</span><br><span class="line">0042FAE0  |.  BA 05000000   mov edx,0x5</span><br><span class="line">0042FAE5  |.  E8 C23EFDFF   call Acid_bur.004039AC</span><br><span class="line">0042FAEA  |.  8D55 F0       lea edx,[local.4]</span><br><span class="line">0042FAED  |.  8B83 E0010000 mov eax,dword ptr ds:[ebx+0x1E0]</span><br><span class="line">0042FAF3  |.  E8 60AFFEFF   call Acid_bur.0041AA58</span><br><span class="line">0042FAF8  |.  8B55 F0       mov edx,[local.4]</span><br><span class="line">0042FAFB  |.  8B45 F4       mov eax,[local.3]                        ;  kernel32.769A7BA9</span><br><span class="line">0042FAFE  |.  E8 F93EFDFF   call Acid_bur.004039FC</span><br></pre></td></tr></table></figure><p>ebx+0x1DC 这个地址出现多次，可能是比较重要的地方。若将其认为是name存储的地方，接下来的逻辑可以说通。</p><p>这段代码中0x431750出现多次：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">0042FA87  |.  8B45 F0       mov eax,[local.4]</span><br><span class="line">0042FA8A  |.  0FB600        movzx eax,byte ptr ds:[eax]</span><br><span class="line">0042FA8D  |.  F72D 50174300 imul dword ptr ds:[0x431750]</span><br><span class="line">0042FA93  |.  A3 50174300   mov dword ptr ds:[0x431750],eax</span><br><span class="line">0042FA98  |.  A1 50174300   mov eax,dword ptr ds:[0x431750]</span><br><span class="line">0042FA9D  |.  0105 50174300 add dword ptr ds:[0x431750],eax</span><br></pre></td></tr></table></figure><p>在此处打上断点，查看内存状态：</p><p><img src="https://shingeki-pic.oss-cn-nanjing.aliyuncs.com/img/20250403234343403.png" alt="image-20250109002002335"></p><p><img src="https://shingeki-pic.oss-cn-nanjing.aliyuncs.com/img/20250403234345615.png" alt="image-20250109002037741"></p><p>计算机为小端序存储，故此处数据为0x29。</p><p>故这段代码含义为：取name的第一个字符的ascii码，乘以0x29（41），再×2。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">0042FA87  |.  8B45 F0       mov eax,[local.4]</span><br><span class="line">0042FA8A  |.  0FB600        movzx eax,byte ptr ds:[eax]</span><br><span class="line">0042FA8D  |.  F72D 50174300 imul dword ptr ds:[0x431750]</span><br><span class="line">0042FA93  |.  A3 50174300   mov dword ptr ds:[0x431750],eax</span><br><span class="line">0042FA98  |.  A1 50174300   mov eax,dword ptr ds:[0x431750]</span><br><span class="line">0042FA9D  |.  0105 50174300 add dword ptr ds:[0x431750],eax</span><br></pre></td></tr></table></figure><p>取上面的样例验证：</p><p>P对应的ascii码为80，乘以41再乘以2，结果为6560，符合。</p><p>1对应ascii码为49，乘以41再乘以2，结果为4018，符合。</p><p>用我自己的名字测试，同样符合规律：</p><img src="https://shingeki-pic.oss-cn-nanjing.aliyuncs.com/img/20250403234349273.png" alt="image-20250109002655515" style="zoom:67%;" /><p>所以注册机的C语言实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">my_register</span><span class="params">(<span class="type">char</span>* name)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> input[<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Enter your name: &quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, input);</span><br><span class="line"></span><br><span class="line">    my_register(input);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">my_register</span><span class="params">(<span class="type">char</span>* name)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strlen</span>(name) &lt; <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Error: Name length must be at least 4 characters.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ori = (<span class="type">int</span>)name[<span class="number">0</span>];</span><br><span class="line">    ori *= <span class="number">82</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;CW-%d-CRACKED\n&quot;</span>, ori);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码也给出了正确的结果。</p><img src="https://shingeki-pic.oss-cn-nanjing.aliyuncs.com/img/20250403234352895.png" alt="image-20250109004154638" style="zoom:67%;" /><hr><h1 id="熊猫烧香实验"><a href="#熊猫烧香实验" class="headerlink" title="熊猫烧香实验"></a>熊猫烧香实验</h1><h2 id="一-病毒观察"><a href="#一-病毒观察" class="headerlink" title="一 病毒观察"></a>一 病毒观察</h2><p>在WinXP系统上观察病毒特征。</p><img src="https://shingeki-pic.oss-cn-nanjing.aliyuncs.com/img/20250403234512592.png" alt="image-20250109102152748" style="zoom:67%;" /><p>将病毒文件复制到虚拟机中并打开。</p><img src="https://shingeki-pic.oss-cn-nanjing.aliyuncs.com/img/20250403234515825.png" alt="image-20250109102249968" style="zoom:67%;" /><p>在任务管理器中可以看到熊猫烧香的进程。过一段时间，任务管理器被自动关闭，应该是病毒的作用。</p><img src="https://shingeki-pic.oss-cn-nanjing.aliyuncs.com/img/20250403234518471.png" alt="image-20250109102354254" style="zoom:67%;" /><p>同时，隐藏文件不会被显示。选择显示所有文件后，点击确定，但隐藏文件并没有显示。再次打开文件夹选项，发现仍然隐藏。</p><img src="https://shingeki-pic.oss-cn-nanjing.aliyuncs.com/img/20250403234521750.png" alt="image-20250109102928536" style="zoom:67%;" /><img src="https://shingeki-pic.oss-cn-nanjing.aliyuncs.com/img/20250403234526473.png" alt="image-20250109103021226" style="zoom:67%;" /><p>Windows安全中心也被关闭，重启后也没有用。</p><img src="https://shingeki-pic.oss-cn-nanjing.aliyuncs.com/img/20250403234528907.png" alt="image-20250109103910095" style="zoom:67%;" /><p>病毒运行一段时间后发现已经无法打开C盘查看文件。</p><img src="https://shingeki-pic.oss-cn-nanjing.aliyuncs.com/img/20250403234531413.png" alt="image-20250109110304443" style="zoom:67%;" /><h2 id="二-病毒分析"><a href="#二-病毒分析" class="headerlink" title="二 病毒分析"></a>二 病毒分析</h2><p>在Win10上用OllyDBG打开老师给的病毒样本，查找所有字符串。</p><p>图中可以看到，当时的主流杀毒软件都在病毒考虑范围之内，查资料发现病毒会关闭这些软件，删除启动项。</p><img src="https://shingeki-pic.oss-cn-nanjing.aliyuncs.com/img/20250403234534146.png" alt="image-20250109103738237" style="zoom:80%;" /><p>追踪到这些ASCII码的位置，这是“防火墙”所在部分：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">0040634A  |.  8B55 90       |mov edx,[local.28]</span><br><span class="line">0040634D  |.  B8 186C4000   |mov eax,41f718bc.00406C18               ;  ASCII &quot;防火墙&quot;</span><br><span class="line">00406352  |.  E8 5DDEFFFF   |call 41f718bc.004041B4</span><br><span class="line">00406357  |.  85C0          |test eax,eax</span><br><span class="line">00406359  |.  74 0C         |je short 41f718bc.00406367</span><br><span class="line">0040635B  |.  6A 00         |push 0x0                                ; /lParam = 0x0</span><br><span class="line">0040635D  |.  6A 00         |push 0x0                                ; |wParam = 0x0</span><br><span class="line">0040635F  |.  6A 12         |push 0x12                               ; |Message = WM_QUIT</span><br><span class="line">00406361  |.  53            |push ebx                                ; |hWnd = 0x7FFDE000</span><br><span class="line">00406362  |.  E8 D5E8FFFF   |call &lt;jmp.&amp;user32.PostMessageA&gt;         ; \PostMessageA</span><br><span class="line">00406367  |&gt;  8D45 8C       |lea eax,[local.29]</span><br><span class="line">0040636A  |.  8BD6          |mov edx,esi                             ;  41f718bc.&lt;ModuleEntryPoint&gt;</span><br><span class="line">0040636C  |.  B9 65000000   |mov ecx,0x65</span><br><span class="line">00406371  |.  E8 3EDBFFFF   |call 41f718bc.00403EB4</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>猜测这里调用的函数可能比较关键，但发现都只是简单的字符串比较，因此关键部分应该在后面。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line">00406951  |.  6A 00         |push 0x0                                ; /lParam = 0x0</span><br><span class="line">00406953  |.  6A 00         |push 0x0                                ; |wParam = 0x0</span><br><span class="line">00406955  |.  6A 12         |push 0x12                               ; |Message = WM_QUIT</span><br><span class="line">00406957  |.  53            |push ebx                                ; |hWnd = 0x7FFDE000</span><br><span class="line">00406958  |.  E8 DFE2FFFF   |call &lt;jmp.&amp;user32.PostMessageA&gt;         ; \PostMessageA</span><br><span class="line">0040695D  |&gt;  85DB          |test ebx,ebx</span><br><span class="line">0040695F  |.^ 0F85 94F9FFFF \jnz 41f718bc.004062F9</span><br><span class="line">00406965  |.  E8 AAE2FFFF   call &lt;jmp.&amp;user32.GetDesktopWindow&gt;      ; [GetDesktopWindow</span><br><span class="line">0040696A  |.  8BF8          mov edi,eax</span><br><span class="line">0040696C  |&gt;  6A 00         /push 0x0                                ; /Title = NULL</span><br><span class="line">0040696E  |.  6A 00         |push 0x0                                ; |Class = 0x0</span><br><span class="line">00406970  |.  53            |push ebx                                ; |hAfterWnd = 7FFDE000</span><br><span class="line">00406971  |.  57            |push edi                                ; |hParent = 0040CB48</span><br><span class="line">00406972  |.  E8 95E2FFFF   |call &lt;jmp.&amp;user32.FindWindowExA&gt;        ; \FindWindowExA</span><br><span class="line">00406977  |.  8BD8          |mov ebx,eax</span><br><span class="line">00406979  |.  6A 00         |push 0x0                                ; /Title = NULL</span><br><span class="line">0040697B  |.  68 906E4000   |push 41f718bc.00406E90                  ; |Class = &quot;msctls_statusbar32&quot;</span><br><span class="line">00406980  |.  6A 00         |push 0x0                                ; |hAfterWnd = NULL</span><br><span class="line">00406982  |.  53            |push ebx                                ; |hParent = 7FFDE000</span><br><span class="line">00406983  |.  E8 84E2FFFF   |call &lt;jmp.&amp;user32.FindWindowExA&gt;        ; \FindWindowExA</span><br><span class="line">00406988  |.  6A 00         |push 0x0                                ; /Title = NULL</span><br><span class="line">0040698A  |.  6A 00         |push 0x0                                ; |Class = 0x0</span><br><span class="line">0040698C  |.  6A 00         |push 0x0                                ; |hAfterWnd = NULL</span><br><span class="line">0040698E  |.  50            |push eax                                ; |hParent = 4DC5976E</span><br><span class="line">0040698F  |.  E8 78E2FFFF   |call &lt;jmp.&amp;user32.FindWindowExA&gt;        ; \FindWindowExA</span><br><span class="line">00406994  |.  6A 65         |push 0x65                               ; /Count = 65 (101.)</span><br><span class="line">00406996  |.  56            |push esi                                ; |Buffer = 41f718bc.&lt;ModuleEntryPoint&gt;</span><br><span class="line">00406997  |.  50            |push eax                                ; |hWnd = 4DC5976E</span><br><span class="line">00406998  |.  E8 87E2FFFF   |call &lt;jmp.&amp;user32.GetWindowTextA&gt;       ; \GetWindowTextA</span><br><span class="line">0040699D  |.  8D85 10FFFFFF |lea eax,[local.60]</span><br><span class="line">004069A3  |.  8BD6          |mov edx,esi                             ;  41f718bc.&lt;ModuleEntryPoint&gt;</span><br><span class="line">004069A5  |.  B9 65000000   |mov ecx,0x65</span><br><span class="line">004069AA  |.  E8 05D5FFFF   |call 41f718bc.00403EB4</span><br><span class="line">004069AF  |.  8B95 10FFFFFF |mov edx,[local.60]</span><br><span class="line">004069B5  |.  B8 AC6E4000   |mov eax,41f718bc.00406EAC               ;  ASCII &quot;pjf(ustc)&quot;</span><br><span class="line">004069BA  |.  E8 F5D7FFFF   |call 41f718bc.004041B4</span><br><span class="line">004069BF  |.  85C0          |test eax,eax</span><br><span class="line">004069C1  |.  0F84 C4000000 |je 41f718bc.00406A8B</span><br><span class="line">004069C7  |.  6A 00         |push 0x0                                ; /lParam = 0x0</span><br><span class="line">004069C9  |.  6A 00         |push 0x0                                ; |wParam = 0x0</span><br><span class="line">004069CB  |.  6A 12         |push 0x12                               ; |Message = WM_QUIT</span><br><span class="line">004069CD  |.  53            |push ebx                                ; |hWnd = 0x7FFDE000</span><br><span class="line">004069CE  |.  E8 69E2FFFF   |call &lt;jmp.&amp;user32.PostMessageA&gt;         ; \PostMessageA</span><br><span class="line">004069D3  |.  6A 00         |push 0x0                                ; /ExtraInfo = 0x0</span><br><span class="line">004069D5  |.  6A 00         |push 0x0                                ; |Flags = 0</span><br><span class="line">004069D7  |.  6A 00         |push 0x0                                ; |/Action = 0x0</span><br><span class="line">004069D9  |.  6A 11         |push 0x11                               ; ||Key = 0x11</span><br><span class="line">004069DB  |.  E8 54E2FFFF   |call &lt;jmp.&amp;user32.MapVirtualKeyA&gt;       ; |\MapVirtualKeyA</span><br><span class="line">004069E0  |.  50            |push eax                                ; |ScanCode = 4DC5976E (1304794990.)</span><br><span class="line">004069E1  |.  6A 11         |push 0x11                               ; |Key = VK_CONTROL</span><br><span class="line">004069E3  |.  E8 64E2FFFF   |call &lt;jmp.&amp;user32.keybd_event&gt;          ; \keybd_event</span><br><span class="line">004069E8  |.  6A 00         |push 0x0                                ; /ExtraInfo = 0x0</span><br><span class="line">004069EA  |.  6A 00         |push 0x0                                ; |Flags = 0</span><br><span class="line">004069EC  |.  6A 00         |push 0x0                                ; |/Action = 0x0</span><br><span class="line">004069EE  |.  6A 12         |push 0x12                               ; ||Key = 0x12</span><br><span class="line">004069F0  |.  E8 3FE2FFFF   |call &lt;jmp.&amp;user32.MapVirtualKeyA&gt;       ; |\MapVirtualKeyA</span><br><span class="line">004069F5  |.  50            |push eax                                ; |ScanCode = 4DC5976E (1304794990.)</span><br><span class="line">004069F6  |.  6A 12         |push 0x12                               ; |Key = VK_MENU</span><br><span class="line">004069F8  |.  E8 4FE2FFFF   |call &lt;jmp.&amp;user32.keybd_event&gt;          ; \keybd_event</span><br><span class="line">004069FD  |.  6A 00         |push 0x0                                ; /ExtraInfo = 0x0</span><br><span class="line">004069FF  |.  6A 00         |push 0x0                                ; |Flags = 0</span><br><span class="line">00406A01  |.  6A 00         |push 0x0                                ; |/Action = 0x0</span><br><span class="line">00406A03  |.  6A 44         |push 0x44                               ; ||Key = 0x44</span><br><span class="line">00406A05  |.  E8 2AE2FFFF   |call &lt;jmp.&amp;user32.MapVirtualKeyA&gt;       ; |\MapVirtualKeyA</span><br><span class="line">00406A0A  |.  50            |push eax                                ; |ScanCode = 4DC5976E (1304794990.)</span><br><span class="line">00406A0B  |.  6A 44         |push 0x44                               ; |Key = 44  (&#x27;D&#x27;)</span><br><span class="line">00406A0D  |.  E8 3AE2FFFF   |call &lt;jmp.&amp;user32.keybd_event&gt;          ; \keybd_event</span><br><span class="line">00406A12  |.  6A 00         |push 0x0                                ; /ExtraInfo = 0x0</span><br><span class="line">00406A14  |.  6A 02         |push 0x2                                ; |Flags = KEYEVENTF_KEYUP</span><br><span class="line">00406A16  |.  6A 00         |push 0x0                                ; |/Action = 0x0</span><br><span class="line">00406A18  |.  6A 44         |push 0x44                               ; ||Key = 0x44</span><br><span class="line">00406A1A  |.  E8 15E2FFFF   |call &lt;jmp.&amp;user32.MapVirtualKeyA&gt;       ; |\MapVirtualKeyA</span><br><span class="line">00406A1F  |.  50            |push eax                                ; |ScanCode = 4DC5976E (1304794990.)</span><br><span class="line">00406A20  |.  6A 44         |push 0x44                               ; |Key = 44  (&#x27;D&#x27;)</span><br><span class="line">00406A22  |.  E8 25E2FFFF   |call &lt;jmp.&amp;user32.keybd_event&gt;          ; \keybd_event</span><br><span class="line">00406A27  |.  6A 00         |push 0x0                                ; /ExtraInfo = 0x0</span><br><span class="line">00406A29  |.  6A 02         |push 0x2                                ; |Flags = KEYEVENTF_KEYUP</span><br><span class="line">00406A2B  |.  6A 00         |push 0x0                                ; |/Action = 0x0</span><br><span class="line">00406A2D  |.  6A 11         |push 0x11                               ; ||Key = 0x11</span><br><span class="line">00406A2F  |.  E8 00E2FFFF   |call &lt;jmp.&amp;user32.MapVirtualKeyA&gt;       ; |\MapVirtualKeyA</span><br><span class="line">00406A34  |.  50            |push eax                                ; |ScanCode = 4DC5976E (1304794990.)</span><br><span class="line">00406A35  |.  6A 11         |push 0x11                               ; |Key = VK_CONTROL</span><br><span class="line">00406A37  |.  E8 10E2FFFF   |call &lt;jmp.&amp;user32.keybd_event&gt;          ; \keybd_event</span><br><span class="line">00406A3C  |.  6A 00         |push 0x0                                ; /ExtraInfo = 0x0</span><br><span class="line">00406A3E  |.  6A 02         |push 0x2                                ; |Flags = KEYEVENTF_KEYUP</span><br><span class="line">00406A40  |.  6A 00         |push 0x0                                ; |/Action = 0x0</span><br><span class="line">00406A42  |.  6A 12         |push 0x12                               ; ||Key = 0x12</span><br><span class="line">00406A44  |.  E8 EBE1FFFF   |call &lt;jmp.&amp;user32.MapVirtualKeyA&gt;       ; |\MapVirtualKeyA</span><br><span class="line">00406A49  |.  50            |push eax                                ; |ScanCode = 4DC5976E (1304794990.)</span><br><span class="line">00406A4A  |.  6A 12         |push 0x12                               ; |Key = VK_MENU</span><br><span class="line">00406A4C  |.  E8 FBE1FFFF   |call &lt;jmp.&amp;user32.keybd_event&gt;          ; \keybd_event</span><br><span class="line">00406A51  |.  68 B86E4000   |push 41f718bc.00406EB8                  ; /Title = &quot;IceSword&quot;</span><br><span class="line">00406A56  |.  6A 00         |push 0x0                                ; |Class = 0x0</span><br><span class="line">00406A58  |.  E8 A7E1FFFF   |call &lt;jmp.&amp;user32.FindWindowA&gt;          ; \FindWindowA</span><br><span class="line">00406A5D  |.  85C0          |test eax,eax</span><br><span class="line">00406A5F  |.  74 2A         |je short 41f718bc.00406A8B</span><br><span class="line">00406A61  |.  6A 00         |push 0x0                                ; /ExtraInfo = 0x0</span><br><span class="line">00406A63  |.  6A 00         |push 0x0                                ; |Flags = 0</span><br><span class="line">00406A65  |.  6A 00         |push 0x0                                ; |/Action = 0x0</span><br><span class="line">00406A67  |.  6A 0D         |push 0xD                                ; ||Key = 0xD</span><br><span class="line">00406A69  |.  E8 C6E1FFFF   |call &lt;jmp.&amp;user32.MapVirtualKeyA&gt;       ; |\MapVirtualKeyA</span><br><span class="line">00406A6E  |.  50            |push eax                                ; |ScanCode = 4DC5976E (1304794990.)</span><br><span class="line">00406A6F  |.  6A 0D         |push 0xD                                ; |Key = VK_RETURN</span><br><span class="line">00406A71  |.  E8 D6E1FFFF   |call &lt;jmp.&amp;user32.keybd_event&gt;          ; \keybd_event</span><br><span class="line">00406A76  |.  6A 00         |push 0x0                                ; /ExtraInfo = 0x0</span><br><span class="line">00406A78  |.  6A 02         |push 0x2                                ; |Flags = KEYEVENTF_KEYUP</span><br><span class="line">00406A7A  |.  6A 00         |push 0x0                                ; |/Action = 0x0</span><br><span class="line">00406A7C  |.  6A 0D         |push 0xD                                ; ||Key = 0xD</span><br><span class="line">00406A7E  |.  E8 B1E1FFFF   |call &lt;jmp.&amp;user32.MapVirtualKeyA&gt;       ; |\MapVirtualKeyA</span><br><span class="line">00406A83  |.  50            |push eax                                ; |ScanCode = 4DC5976E (1304794990.)</span><br><span class="line">00406A84  |.  6A 0D         |push 0xD                                ; |Key = VK_RETURN</span><br><span class="line">00406A86  |.  E8 C1E1FFFF   |call &lt;jmp.&amp;user32.keybd_event&gt;          ; \keybd_event</span><br><span class="line">00406A8B  |&gt;  85DB          |test ebx,ebx</span><br><span class="line">00406A8D  |.^ 0F85 D9FEFFFF \jnz 41f718bc.0040696C</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以看到病毒调用 <code>FindWindowA</code> 和 <code>FindWindowExA</code> 查找特定窗口，并向窗口发送 <code>WM_QUIT</code> 消息来尝试终止。</p><p>后面还有一段代码，实现了关闭关键进程的逻辑。</p><img src="https://shingeki-pic.oss-cn-nanjing.aliyuncs.com/img/20250403234540481.png" alt="image-20250109111412273" style="zoom:67%;" /><p>追踪调用的函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">004060D4  /$  55            push ebp</span><br><span class="line">004060D5  |.  8BEC          mov ebp,esp</span><br><span class="line">004060D7  |.  81C4 C0FEFFFF add esp,-0x140</span><br><span class="line">004060DD  |.  53            push ebx</span><br><span class="line">004060DE  |.  56            push esi                                 ;  41f718bc.&lt;ModuleEntryPoint&gt;</span><br><span class="line">004060DF  |.  33D2          xor edx,edx                              ;  41f718bc.&lt;ModuleEntryPoint&gt;</span><br><span class="line">004060E1  |.  8995 D0FEFFFF mov [local.76],edx                       ;  41f718bc.&lt;ModuleEntryPoint&gt;</span><br><span class="line">004060E7  |.  8995 C8FEFFFF mov [local.78],edx                       ;  41f718bc.&lt;ModuleEntryPoint&gt;</span><br><span class="line">004060ED  |.  8995 C4FEFFFF mov [local.79],edx                       ;  41f718bc.&lt;ModuleEntryPoint&gt;</span><br><span class="line">004060F3  |.  8995 C0FEFFFF mov [local.80],edx                       ;  41f718bc.&lt;ModuleEntryPoint&gt;</span><br><span class="line">004060F9  |.  8995 CCFEFFFF mov [local.77],edx                       ;  41f718bc.&lt;ModuleEntryPoint&gt;</span><br><span class="line">004060FF  |.  8945 FC       mov [local.1],eax</span><br><span class="line">00406102  |.  8B45 FC       mov eax,[local.1]</span><br><span class="line">00406105  |.  E8 B2DFFFFF   call 41f718bc.004040BC</span><br><span class="line">0040610A  |.  8D9D D4FEFFFF lea ebx,[local.75]</span><br><span class="line">00406110  |.  33C0          xor eax,eax</span><br><span class="line">00406112  |.  55            push ebp</span><br><span class="line">00406113  |.  68 06624000   push 41f718bc.00406206</span><br><span class="line">00406118  |.  64:FF30       push dword ptr fs:[eax]</span><br><span class="line">0040611B  |.  64:8920       mov dword ptr fs:[eax],esp</span><br><span class="line">0040611E  |.  33D2          xor edx,edx                              ;  41f718bc.&lt;ModuleEntryPoint&gt;</span><br><span class="line">00406120  |.  B8 02000000   mov eax,0x2</span><br><span class="line">00406125  |.  E8 FEEEFFFF   call 41f718bc.00405028</span><br><span class="line">0040612A  |.  8BF0          mov esi,eax</span><br><span class="line">0040612C  |.  C703 28010000 mov dword ptr ds:[ebx],0x128</span><br><span class="line">00406132  |.  8BD3          mov edx,ebx</span><br><span class="line">00406134  |.  8BC6          mov eax,esi                              ;  41f718bc.&lt;ModuleEntryPoint&gt;</span><br><span class="line">00406136  |.  E8 0DEFFFFF   call 41f718bc.00405048</span><br><span class="line">0040613B  |.  83F8 01       cmp eax,0x1</span><br><span class="line">0040613E  |.  1BC0          sbb eax,eax</span><br><span class="line">00406140  |.  40            inc eax</span><br><span class="line">00406141  |.  E9 8A000000   jmp 41f718bc.004061D0</span><br><span class="line">00406146  |&gt;  8D95 CCFEFFFF /lea edx,[local.77]</span><br><span class="line">0040614C  |.  8B45 FC       |mov eax,[local.1]</span><br><span class="line">0040614F  |.  E8 D4FEFFFF   |call 41f718bc.00406028</span><br><span class="line">00406154  |.  8B85 CCFEFFFF |mov eax,[local.77]</span><br><span class="line">0040615A  |.  8D95 D0FEFFFF |lea edx,[local.76]</span><br><span class="line">00406160  |.  E8 43FEFFFF   |call 41f718bc.00405FA8</span><br><span class="line">00406165  |.  8B85 D0FEFFFF |mov eax,[local.76]</span><br><span class="line">0040616B  |.  50            |push eax</span><br><span class="line">0040616C  |.  8D85 C0FEFFFF |lea eax,[local.80]</span><br><span class="line">00406172  |.  8D53 24       |lea edx,dword ptr ds:[ebx+0x24]</span><br><span class="line">00406175  |.  B9 04010000   |mov ecx,0x104</span><br><span class="line">0040617A  |.  E8 35DDFFFF   |call 41f718bc.00403EB4</span><br><span class="line">0040617F  |.  8B85 C0FEFFFF |mov eax,[local.80]</span><br><span class="line">00406185  |.  8D95 C4FEFFFF |lea edx,[local.79]</span><br><span class="line">0040618B  |.  E8 98FEFFFF   |call 41f718bc.00406028</span><br><span class="line">00406190  |.  8B85 C4FEFFFF |mov eax,[local.79]</span><br><span class="line">00406196  |.  8D95 C8FEFFFF |lea edx,[local.78]</span><br><span class="line">0040619C  |.  E8 07FEFFFF   |call 41f718bc.00405FA8</span><br><span class="line">004061A1  |.  8B95 C8FEFFFF |mov edx,[local.78]</span><br><span class="line">004061A7  |.  58            |pop eax                                 ;  kernel32.75833744</span><br><span class="line">004061A8  |.  E8 6BDEFFFF   |call 41f718bc.00404018</span><br><span class="line">004061AD  |.  75 12         |jnz short 41f718bc.004061C1</span><br><span class="line">004061AF  |.  8B43 08       |mov eax,dword ptr ds:[ebx+0x8]          ;  41f718bc.00400000</span><br><span class="line">004061B2  |.  E8 FDFEFFFF   |call 41f718bc.004060B4</span><br><span class="line">004061B7  |.  8BD8          |mov ebx,eax</span><br><span class="line">004061B9  |.  56            |push esi                                ; /hObject = 0040CB48</span><br><span class="line">004061BA  |.  E8 1DE9FFFF   |call &lt;jmp.&amp;kernel32.CloseHandle&gt;        ; \CloseHandle</span><br><span class="line">004061BF  |.  EB 1F         |jmp short 41f718bc.004061E0</span><br><span class="line">004061C1  |&gt;  8BD3          |mov edx,ebx</span><br><span class="line">004061C3  |.  8BC6          |mov eax,esi                             ;  41f718bc.&lt;ModuleEntryPoint&gt;</span><br><span class="line">004061C5  |.  E8 9EEEFFFF   |call 41f718bc.00405068</span><br><span class="line">004061CA  |.  83F8 01       |cmp eax,0x1</span><br><span class="line">004061CD  |.  1BC0          |sbb eax,eax</span><br><span class="line">004061CF  |.  40            |inc eax</span><br><span class="line">004061D0  |&gt;  84C0           test al,al</span><br><span class="line">004061D2  |.^ 0F85 6EFFFFFF \jnz 41f718bc.00406146</span><br><span class="line">004061D8  |.  56            push esi                                 ; /hObject = 0040CB48</span><br><span class="line">004061D9  |.  E8 FEE8FFFF   call &lt;jmp.&amp;kernel32.CloseHandle&gt;         ; \CloseHandle</span><br><span class="line">004061DE  |.  B3 01         mov bl,0x1</span><br><span class="line">004061E0  |&gt;  33C0          xor eax,eax</span><br><span class="line">004061E2  |.  5A            pop edx                                  ;  kernel32.75833744</span><br><span class="line">004061E3  |.  59            pop ecx                                  ;  kernel32.75833744</span><br><span class="line">004061E4  |.  59            pop ecx                                  ;  kernel32.75833744</span><br><span class="line">004061E5  |.  64:8910       mov dword ptr fs:[eax],edx               ;  41f718bc.&lt;ModuleEntryPoint&gt;</span><br><span class="line">004061E8  |.  68 0D624000   push 41f718bc.0040620D</span><br><span class="line">004061ED  |&gt;  8D85 C0FEFFFF lea eax,[local.80]</span><br><span class="line">004061F3  |.  BA 05000000   mov edx,0x5</span><br><span class="line">004061F8  |.  E8 6BDAFFFF   call 41f718bc.00403C68</span><br><span class="line">004061FD  |.  8D45 FC       lea eax,[local.1]</span><br><span class="line">00406200  |.  E8 3FDAFFFF   call 41f718bc.00403C44</span><br><span class="line">00406205  \.  C3            retn</span><br></pre></td></tr></table></figure><p>其中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">004061D9  |.  E8 FEE8FFFF   call &lt;jmp.&amp;kernel32.CloseHandle&gt;         ; \CloseHandle</span><br></pre></td></tr></table></figure><p>这一行是关键，可以看出病毒在此处结束了一些可能影响自己运行的进程。</p><p>这里大概可以看出，病毒在一些关键位置感染文件，会新建Desktop_.ini文件。</p><img src="https://shingeki-pic.oss-cn-nanjing.aliyuncs.com/img/20250403234545528.png" alt="image-20250109104320922" style="zoom: 80%;" /><p>定位到附近，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">00409886   .  FF75 FC       push dword ptr ss:[ebp-0x4]</span><br><span class="line">00409889   .  FFB5 A8FEFFFF push dword ptr ss:[ebp-0x158]</span><br><span class="line">0040988F   .  68 94A04000   push 41f718bc.0040A094                   ;  ASCII 5C,&quot;Desktop_.ini&quot;</span><br><span class="line">00409894   .  8D85 C0FDFFFF lea eax,dword ptr ss:[ebp-0x240]</span><br><span class="line">0040989A   .  BA 03000000   mov edx,0x3</span><br><span class="line">0040989F   .  E8 E8A6FFFF   call 41f718bc.00403F8C</span><br><span class="line">004098A4   .  8B85 C0FDFFFF mov eax,dword ptr ss:[ebp-0x240]</span><br><span class="line">004098AA   .  E8 1DA8FFFF   call 41f718bc.004040CC</span><br><span class="line">004098AF   .  50            push eax                                 ; |FileName = 4DC5976E ???</span><br><span class="line">004098B0   .  E8 FFB2FFFF   call &lt;jmp.&amp;kernel32.SetFileAttributesA&gt;  ; \SetFileAttributesA</span><br><span class="line">004098B5   .  6A 01         push 0x1                                 ; /Timeout = 1. ms</span><br><span class="line">004098B7   .  E8 08B3FFFF   call &lt;jmp.&amp;kernel32.Sleep&gt;               ; \Sleep</span><br><span class="line">004098BC   .  8D85 8CFEFFFF lea eax,dword ptr ss:[ebp-0x174]</span><br><span class="line">004098C2   .  50            push eax                                 ; /pLocaltime = 4DC5976E</span><br><span class="line">004098C3   .  E8 9CB2FFFF   call &lt;jmp.&amp;kernel32.GetLocalTime&gt;        ; \GetLocalTime</span><br><span class="line">004098C8   .  8D95 BCFDFFFF lea edx,dword ptr ss:[ebp-0x244]</span><br><span class="line">004098CE   .  0FB785 8CFEFF&gt;movzx eax,word ptr ss:[ebp-0x174]</span><br><span class="line">004098D5   .  E8 A2BFFFFF   call 41f718bc.0040587C</span><br><span class="line">004098DA   .  FFB5 BCFDFFFF push dword ptr ss:[ebp-0x244]</span><br><span class="line">004098E0   .  68 ACA04000   push 41f718bc.0040A0AC                   ;  UNICODE &quot;-&quot;</span><br><span class="line">004098E5   .  8D95 B8FDFFFF lea edx,dword ptr ss:[ebp-0x248]</span><br><span class="line">004098EB   .  0FB785 8EFEFF&gt;movzx eax,word ptr ss:[ebp-0x172]</span><br><span class="line">004098F2   .  E8 85BFFFFF   call 41f718bc.0040587C</span><br><span class="line">004098F7   .  FFB5 B8FDFFFF push dword ptr ss:[ebp-0x248]</span><br><span class="line">004098FD   .  68 ACA04000   push 41f718bc.0040A0AC                   ;  UNICODE &quot;-&quot;</span><br><span class="line">00409902   .  8D95 B4FDFFFF lea edx,dword ptr ss:[ebp-0x24C]</span><br><span class="line">00409908   .  0FB785 92FEFF&gt;movzx eax,word ptr ss:[ebp-0x16E]</span><br><span class="line">0040990F   .  E8 68BFFFFF   call 41f718bc.0040587C</span><br><span class="line">00409914   .  FFB5 B4FDFFFF push dword ptr ss:[ebp-0x24C]</span><br><span class="line">0040991A   .  8D45 F4       lea eax,dword ptr ss:[ebp-0xC]</span><br><span class="line">0040991D   .  BA 05000000   mov edx,0x5</span><br><span class="line">00409922   .  E8 65A6FFFF   call 41f718bc.00403F8C</span><br></pre></td></tr></table></figure><p>发现这段代码中有设置时间戳、设置文件属性的部分，病毒应该在这里将文件的属性设为了隐藏。</p><p>下面这段代码中出现了gamesetup.exe和spoclsv.exe，且存在复制的行为，可能是病毒复制自身的地方。</p><img src="https://shingeki-pic.oss-cn-nanjing.aliyuncs.com/img/20250403234551277.png" alt="image-20250109131621011" style="zoom: 67%;" />]]></content>
      
      
      <categories>
          
          <category> 作业/报告 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件安全 </tag>
            
            <tag> AFL </tag>
            
            <tag> 模糊测试 </tag>
            
            <tag> Crackme </tag>
            
            <tag> Metasploit </tag>
            
            <tag> kali </tag>
            
            <tag> MS08-067 </tag>
            
            <tag> 漏洞 </tag>
            
            <tag> 熊猫烧香 </tag>
            
            <tag> OllyDBG </tag>
            
            <tag> DVWA </tag>
            
            <tag> Seay </tag>
            
            <tag> RIPS </tag>
            
            <tag> CodeXploiter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>毕设前端经验总结</title>
      <link href="/2025/04/03/graduate-proj-exp/"/>
      <url>/2025/04/03/graduate-proj-exp/</url>
      
        <content type="html"><![CDATA[<h1 id="一"><a href="#一" class="headerlink" title="一"></a>一</h1><p>利用了element plus的自动导入，使用ElMessage、ElDivider等出现报错：  <code>Vue: Cannot find name &#39;ElMessage&#39;.</code></p><p>但实际使用没有问题，IDE也能给出ElMessage的具体位置。</p><p>环境：vue3 + vite + ts，没有eslint，</p><p>修改tsconfig.json，添加 <code>&quot;include&quot;: [&quot;./auto-imports.d.ts&quot;]</code>，没有效果。</p><p>后续修改tsconfig.app.json，在include中添加auto-imports.d.ts，并清除IDE缓存，重启，报错解决。</p><hr><h1 id="二"><a href="#二" class="headerlink" title="二"></a>二</h1><p><code>Expected Number with value XX, got String with value “XX“ </code></p><p>这个报错是因为组件将数字当作字符串处理了。</p><p>在 <code>fill-ratio=100</code> 前面加上冒号即可（绑定表达式）</p><hr><h1 id="三"><a href="#三" class="headerlink" title="三"></a>三</h1><p>在某次merge之后，新合并进来的部分中导入了一些新的包，随后发现Webstorm无法识别element plus的次级组件（比如el-description-item、el-row等等），其他组件正常识别。查看components.d.ts，能够找到次级组件的定义。</p><p>初步尝试清除IDE缓存重新编制索引后并无效果。</p><p>后来删除了package-lock.json以及node_modules文件夹，重新运行<code>npm install</code>。另外，同时在tsconfig.json中添加了代码</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;compilerOptions&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;types&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;element-plus/global&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;include&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;src/**/*&quot;</span><span class="punctuation">,</span> <span class="string">&quot;components.d.ts&quot;</span><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br></pre></td></tr></table></figure><p>此后不再报错。</p><p>猜测应该是重新安装依赖修复了问题，与 tsconfig.json 的修改无关。</p><p>遇到IDE出现无法识别HTML标签的错误，大概几种方法：</p><ol><li>修改项目配置文件</li><li>清除IDE缓存重启</li><li>备份并删除package-lock.json，删除node_modules文件夹</li></ol><p>大概就这些，目前没有遇到例外。可能存在屠龙之术，但现在我见识少，也没碰到这条龙。</p><hr><h1 id="四"><a href="#四" class="headerlink" title="四"></a>四</h1><p>el-menu中使用router的时候：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">el-menu</span></span></span><br><span class="line"><span class="tag">      <span class="attr">class</span>=<span class="string">&quot;el-menu-demo&quot;</span></span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag">      <span class="attr">mode</span>=<span class="string">&quot;horizontal&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">:ellipsis</span>=<span class="string">&quot;false&quot;</span></span></span><br><span class="line"><span class="tag">      @<span class="attr">select</span>=<span class="string">&quot;handleSelect&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">:default-active</span>=<span class="string">&quot;$route.path&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">router</span></span></span><br><span class="line"><span class="tag">      <span class="attr">style</span>=<span class="string">&quot;height: 65px&quot;</span></span></span><br><span class="line"><span class="tag">  &gt;</span></span><br></pre></td></tr></table></figure><p>如果使用二级菜单，即这种写法：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">el-menu-item</span> <span class="attr">index</span>=<span class="string">&quot;/attack&quot;</span> <span class="attr">style</span>=<span class="string">&quot;font-weight: bold&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">el-menu-item</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">el-sub-menu</span> <span class="attr">index</span>=<span class="string">&quot;/&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">template</span> #<span class="attr">title</span>&gt;</span><span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">&quot;font-weight: bold&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">el-menu-item</span> <span class="attr">index</span>=<span class="string">&quot;/kill-bad-code&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">el-menu-item</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">el-menu-item</span> <span class="attr">index</span>=<span class="string">&quot;/eli-bad-code&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">el-menu-item</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">el-sub-menu</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">el-menu-item</span> <span class="attr">index</span>=<span class="string">&quot;/task&quot;</span> <span class="attr">style</span>=<span class="string">&quot;font-weight: bold&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">el-menu-item</span>&gt;</span></span><br></pre></td></tr></table></figure><p>系统会识别每个菜单项，也就是<code>&lt;el-menu-item&gt;</code>的index，点击时作为路由进行跳转。</p><p>而<code>&lt;el-sub-menu index=&quot;/&quot;&gt;</code>的index，与路由无关，即使设置了存在的路由，点击了也不会跳转。</p><hr><h1 id="五"><a href="#五" class="headerlink" title="五"></a>五</h1><p>后端已经分页，前端获取数据，但页面变化的时候，发现卡片不会随之变化。</p><p>比如一共15条数据，对应15张卡片，第一页正常显示，切换到第二页后发现后5张卡片没了，这个符合要求，但是前5张卡片没变。</p><p>经查，后端接口无误。</p><p>前端相关逻辑如下，也是没有问题的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">fetchTasks</span> = <span class="keyword">async</span> (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  isLoading.<span class="property">value</span> = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> [taskRes, countRes] = <span class="keyword">await</span> <span class="title class_">Promise</span>.<span class="title function_">all</span>([</span><br><span class="line">      <span class="title function_">getUserTasksByPage</span>(uid, category, currentPage.<span class="property">value</span>, pageSize),</span><br><span class="line">      <span class="title function_">getUserTaskCount</span>(uid, category),</span><br><span class="line">    ]);</span><br><span class="line">    tasks.<span class="property">value</span> = taskRes.<span class="property">data</span>.<span class="property">taskList</span>;</span><br><span class="line">    totalNum.<span class="property">value</span> = countRes.<span class="property">data</span>.<span class="property">count</span>;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;数据加载失败:&#x27;</span>, error)</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    isLoading.<span class="property">value</span> = <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">onMounted</span>(<span class="title function_">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">await</span> <span class="title function_">fetchTasks</span>();</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="title function_">watch</span>(</span><br><span class="line">    <span class="function">() =&gt;</span> route.<span class="property">query</span>.<span class="property">page</span>,</span><br><span class="line">    <span class="title function_">async</span> (newPage) =&gt; &#123;</span><br><span class="line">      currentPage.<span class="property">value</span> = <span class="title class_">Number</span>(newPage) || <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">await</span> <span class="title function_">fetchTasks</span>();</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">handlePageChange</span> = (<span class="params">newPage: number</span>) =&gt; &#123;</span><br><span class="line">  router.<span class="title function_">push</span>(&#123; <span class="attr">path</span>: <span class="string">&quot;/task&quot;</span>, <span class="attr">query</span>: &#123; <span class="attr">page</span>: newPage &#125; &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">el-pagination</span></span></span><br><span class="line"><span class="tag">          <span class="attr">background</span></span></span><br><span class="line"><span class="tag">          <span class="attr">layout</span>=<span class="string">&quot;total,prev,pager,next&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">:total</span>=<span class="string">&quot;totalNum&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">:page-size</span>=<span class="string">&quot;pageSize&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">:current-page</span>=<span class="string">&quot;currentPage&quot;</span></span></span><br><span class="line"><span class="tag">          @<span class="attr">current-change</span>=<span class="string">&quot;handlePageChange&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">size</span>=<span class="string">&quot;large&quot;</span></span></span><br><span class="line"><span class="tag">      /&gt;</span></span><br></pre></td></tr></table></figure><p>后来问GPT，才找到问题关键：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">TaskCard</span></span></span><br><span class="line"><span class="tag">          <span class="attr">v-for</span>=<span class="string">&quot;(item, index) in tasks&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">:key</span>=<span class="string">&quot;index&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">:data</span>=<span class="string">&quot;item&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">:similar-tasks</span>=<span class="string">&quot;getSimilarTasks(item)&quot;</span></span></span><br><span class="line"><span class="tag">      /&gt;</span></span><br></pre></td></tr></table></figure><p>TaskCard里面绑的key是index，而当tasks刷新的时候，这些key实际上没变，vue就不会重新渲染。</p><p>修改之后就好了：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">TaskCard</span></span></span><br><span class="line"><span class="tag">          <span class="attr">v-for</span>=<span class="string">&quot;item in tasks&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">:key</span>=<span class="string">&quot;item.tid&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">:data</span>=<span class="string">&quot;item&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">:similar-tasks</span>=<span class="string">&quot;getSimilarTasks(item)&quot;</span></span></span><br><span class="line"><span class="tag">      /&gt;</span></span><br></pre></td></tr></table></figure><hr>]]></content>
      
      
      <categories>
          
          <category> 经验总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> vue </tag>
            
            <tag> element-plus </tag>
            
            <tag> element </tag>
            
            <tag> vue3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo及butterfly主题使用踩坑记录</title>
      <link href="/2025/04/02/butterfly-learning/"/>
      <url>/2025/04/02/butterfly-learning/</url>
      
        <content type="html"><![CDATA[<h2 id="一"><a href="#一" class="headerlink" title="一"></a>一</h2><p>将_config.yml中的post_asset_folder项设为true，安装hexo-asset-image之后，运行hexo new post的时候会新建一个同名文件夹，文档中可以直接引用文件夹中图片，不需要额外路径。比如cover配置项，直接在文章的front matter里面写：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">cover:</span> <span class="string">xxx.jpg</span></span><br></pre></td></tr></table></figure><p>即可，图片能够正常显示。</p><p><img src="https://shingeki-pic.oss-cn-nanjing.aliyuncs.com/img/20250402110115964.png"></p><p>根据官方文档的说法，文章页顶部图的获取顺序为各自配置的 top_img &gt; cover &gt; 配置文件的 default_top_img，目前我没有配置top_img的情况下，应该取cover作为顶部图片，再不济也要用上我设置的default_top_img，但实际上并非如此：</p><p><img src="https://shingeki-pic.oss-cn-nanjing.aliyuncs.com/img/20250402110206214.png"></p><p>文章的top_img并没有引用任何图片，只有主题色。</p><p>查文档发现top_img也是front-matter里面内容之一，于是添加配置项</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">top_img:</span> <span class="string">xxx.jpg</span></span><br></pre></td></tr></table></figure><p>但依然没有效果。</p><p>随后发现，将图片保存到butterfly\source\img文件夹下，以&#x2F;img&#x2F;xxx.jpg的形式引用，则可以正常生效。只设置cover的时候也可以一同影响到top_img，符合官方文档说法。</p><p>所以最好还是将这些图片存个图床吧。</p><hr><h2 id="二"><a href="#二" class="headerlink" title="二"></a>二</h2><p>有的时候，加粗的字体不生效，但在typora中显示正常：</p><p><strong>源文本：</strong></p><img src="https://shingeki-pic.oss-cn-nanjing.aliyuncs.com/img/20250404130537068.png" style="zoom: 67%;" /><p><strong>Typora中渲染效果：</strong></p><img src="https://shingeki-pic.oss-cn-nanjing.aliyuncs.com/img/20250404130613210.png" style="zoom:67%;" /><p><strong>博客展示效果：</strong></p><img src="https://shingeki-pic.oss-cn-nanjing.aliyuncs.com/img/20250404130454240.png" style="zoom:67%;" /><p>查阅资料发现，在hexo中，加粗所用的 ** 符号需要遵循如下规则：</p><blockquote><p>开始标记符的前后必须满足：</p><ol><li>不能后跟空白</li><li>标点符号<ul><li>不能后跟标点符号</li><li>如果后跟标点符号，则前面必须有空白</li></ul></li></ol><p>结束标记符的规则和开始标记符相反：</p><ol><li>前面不能是空白</li><li>标点符号：<ul><li>前面不能是标点符号</li><li>如果前面是标点符号，则后面必须有空白</li></ul></li></ol></blockquote><p>添加空格之后显示正常：</p><img src="https://shingeki-pic.oss-cn-nanjing.aliyuncs.com/img/20250404130857777.png" style="zoom:67%;" /><p>且经过测试发现，英文与中文的标点符号都是符合上述规则的。</p><hr>]]></content>
      
      
      <categories>
          
          <category> 经验总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> butterfly </tag>
            
            <tag> 主题 </tag>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>王道OS看书笔记——I/O管理</title>
      <link href="/2025/03/31/OS-learning-4/"/>
      <url>/2025/03/31/OS-learning-4/</url>
      
        <content type="html"><![CDATA[<p>本文为我考研期间看王道书时写的飞书笔记，根据各知识点的逻辑关系进行整理，添加了一点自己的理解，内容不如王道书全。</p><h2 id="I-O管理概述"><a href="#I-O管理概述" class="headerlink" title="I&#x2F;O管理概述"></a>I&#x2F;O管理概述</h2><h3 id="I-O设备"><a href="#I-O设备" class="headerlink" title="I&#x2F;O设备"></a>I&#x2F;O设备</h3><ul><li><p>按信息交换的单位分类</p><ul><li><strong>块设备</strong><ul><li>信息交换以数据块为单位，如磁盘 磁带等</li><li>传输速率高 可寻址（随机读写任意一块）</li></ul></li><li><strong>字符设备</strong><ul><li>信息交换以字符为单位，如交互式终端机、打印机等</li><li>传输速率低 不可寻址 时常采用中断I&#x2F;O方式</li></ul></li></ul></li><li><p>按设备使用特性分类</p><ul><li>存储设备<ul><li>硬盘 磁带 光盘等</li></ul></li><li>输入输出设备<ul><li>键盘 鼠标 扫描仪 打印机 触控显示器</li></ul></li></ul></li><li><p><strong>I&#x2F;O接口（设备控制器）</strong></p><ul><li>CPU和设备之间的接口，实现设备和计算机的数据交换</li><li>接收CPU的命令，控制设备工作<br><img src="https://shingeki-pic.oss-cn-nanjing.aliyuncs.com/img/20250402111815713.png"></li><li>设备控制器与CPU的接口<ul><li>实现CPU和设备控制器之间的通信</li><li>有三类信号线<ul><li>数据线 传送读写数据 控制信息和状态信息</li><li>地址线 传送要访问I&#x2F;O接口中的寄存器编号</li><li>控制线 传送读写等控制信号</li></ul></li></ul></li><li>设备控制器和设备的接口<ul><li>一个设备控制器可以连接一个&#x2F;多个设备，控制器中有一个&#x2F;多个设备接口</li><li>每个接口都可以传输数据 控制 状态信号</li></ul></li><li>I&#x2F;O逻辑<ul><li>实现对设备的控制</li><li>通过一组控制线和CPU交互，对收到的I&#x2F;O命令译码</li></ul></li><li>设备控制器主要功能<ul><li>接收 识别命令</li><li>数据交换</li><li>标识和报告设备状态</li><li>地址识别</li><li>数据缓冲</li><li>差错控制</li></ul></li></ul></li><li><p><strong>I&#x2F;O端口</strong></p><ul><li>指设备控制器中可被CPU直接访问的<strong>寄存器</strong><ul><li>数据寄存器</li><li>状态寄存器</li><li>控制寄存器</li></ul></li><li>I&#x2F;O端口需要对各个端口编址使得能够被CPU访问<ul><li>编址方式有与存储器独立编址和统一编址两种<br><img src="https://shingeki-pic.oss-cn-nanjing.aliyuncs.com/img/20250402111828441.png"><ul><li><strong>独立编址</strong><ul><li>每个端口分配一个I&#x2F;O端口号</li><li>I&#x2F;O端口地址空间和主存地址空间是两个独立的地址空间<ul><li>它们的范围可以重叠<ul><li>GPT: 虽然I&#x2F;O端口和主存各自有独立的地址空间，但它们的地址范围可能存在<strong>重叠</strong>。例如，在某些架构中，<strong>I&#x2F;O设备可能使用与主存相同的物理地址</strong>，但操作系统和硬件通过不同的机制区分这些地址。<strong>重叠并不意味着冲突</strong>，因为通过特定的指令或访问方式（如通过I&#x2F;O指令或内存读写指令）来区分是访问I&#x2F;O设备还是访问主存。</li></ul></li><li>相同地址可能属于不同的地址空间<ul><li>GPT: <strong>相同地址</strong>指的是某个数值可以出现在I&#x2F;O地址空间中，也可以出现在主存地址空间中。例如，地址<code>0x1000</code>既可以是一个内存地址，也可以是一个I&#x2F;O端口地址。操作系统或CPU通过不同的指令集（如<code>IN</code>和<code>OUT</code>用于I&#x2F;O操作，<code>MOV</code>用于内存操作）来确定是访问哪个地址空间。</li></ul></li></ul></li><li><strong>优点：</strong><ul><li>I&#x2F;O端口数比主存单元少得多，只需少量地址线，使得I&#x2F;O端口译码简单，寻址速度更快</li><li>使用专用I&#x2F;O指令，程序更加清晰，便于理解检查</li></ul></li><li><strong>缺点：</strong><ul><li>I&#x2F;O指令少，只提供简单的传输操作，程序设计灵活性较差</li><li>CPU需要提供两组独立的存储器和设备的读写控制信号，增加控制复杂性</li></ul></li></ul></li><li><strong>统一编址</strong><ul><li>又称内存映射I&#x2F;O</li><li>将主存地址空间分出一部分给I&#x2F;O端口编址</li><li>I&#x2F;O端口和主存单元在同一地址空间不同分段中</li><li>根据地址范围就能区分访问的是I&#x2F;O端口还是主存单元，不需要专门I&#x2F;O指令</li><li><strong>优点：</strong><ul><li>不需要专门的I&#x2F;O指令，CPU访问I&#x2F;O更加灵活</li><li>端口有较大编制空间</li><li>I&#x2F;O访问的保护机制由虚拟存储管理系统实现，无需专门设置</li></ul></li><li><strong>缺点</strong><ul><li>端口地址占用了部分主存地址空间，主存可用容量变小</li><li>识别I&#x2F;O时，全部地址线参加译码，译码电路更复杂，降低了寻址速度</li></ul></li></ul></li></ul></li></ul></li></ul></li></ul><h3 id="I-O控制方式"><a href="#I-O控制方式" class="headerlink" title="I&#x2F;O控制方式"></a>I&#x2F;O控制方式</h3><ul><li><p><strong>I&#x2F;O控制</strong>是指控制设备和主机之间的数据传送</p></li><li><p>要求尽量减少CPU对I&#x2F;O控制的干预，更多地执行运算任务</p></li><li><p><strong>3种I&#x2F;O控制方式</strong><br><img src="https://shingeki-pic.oss-cn-nanjing.aliyuncs.com/img/20250402111835776.png"></p><ul><li><strong>程序直接控制方式</strong><ul><li>CPU对I&#x2F;O设备的控制采取<strong>轮询</strong>的I&#x2F;O方式</li><li>又称程序轮询方式</li><li><strong>过程</strong><ul><li>CPU向设备控制器发出一条I&#x2F;O指令，从I&#x2F;O设备读一个字（节）</li><li>不断地循环测试设备状态，直到确定该字（节）已在设备控制器的数据寄存器里</li><li>CPU将数据寄存器中数据取出，送入内存指定单元</li></ul></li><li>优点：简单易于实现</li><li>缺点：<ul><li>CPU绝大部分时间都在轮询，CPU和I&#x2F;O设备只能串行工作<ul><li>CPU和I&#x2F;O设备速度差距大，导致CPU利用率很低</li></ul></li></ul></li></ul></li><li><strong>中断驱动方式（10 17 23 24）</strong><ul><li>允许I&#x2F;O设备主动打断CPU运行并请求服务</li><li>CPU向设备控制器发出一条I&#x2F;O指令后可以继续做其他工作</li><li><strong>设备控制器角度的过程</strong><ul><li>设备控制器从CPU接收一个读命令，从设备读数据</li><li>读入数据寄存器后，通过控制线给CPU发出中断信号，表示数据已经准备好</li><li>等待CPU请求数据</li><li>收到CPU取数据请求后，将数据放到数据总线上，传到CPU寄存器中</li></ul></li><li><strong>CPU角度的过程</strong><ul><li>当前运行进程发出读命令，进程被阻塞，保存上下文，执行其他程序</li><li>每个指令周期的末尾，CPU检查中断信号</li><li>有来自设备控制器的中断时，CPU保存当前运行进程的上下文，执行中断处理程序</li><li>此时CPU从设备控制器读一个字的数据传送到寄存器，并存入主存</li><li>中断处理完后解除发出I&#x2F;O命令的进程的阻塞状态，恢复该进程（或其他进程）的上下文</li></ul></li><li><strong>优点：</strong><ul><li>CPU和设备并行工作，CPU利用率明显提升</li></ul></li><li><strong>缺点：</strong><ul><li>设备和内存之间数据交换必须经过CPU中寄存器</li><li>CPU以字（节）为单位干预，若用于块设备的I&#x2F;O操作，效率很低</li></ul></li></ul></li><li><strong>DMA方式（17）</strong><ul><li>DMA（Direct Memory Access，直接存储器存取）<br><img src="https://shingeki-pic.oss-cn-nanjing.aliyuncs.com/img/20250402111843178.png"></li><li>在<strong>I&#x2F;O设备和内存之间</strong>开辟直接的数据交换通路</li><li>特点<ul><li>基本传送单位是数据块</li><li>传送的数据从设备直接送入内存，或者相反，不经过CPU</li><li>仅在传送一个或多个数据块的开始和结束时，需要CPU干预</li></ul></li><li>为了实现主机和控制器之间直接交换成块的数据，需要在DMA控制器中设置4类寄存器：<ul><li>命令&#x2F;状态寄存器（CR）<ul><li>接收从CPU发来的I&#x2F;O命令 有关的控制信息 设备的状态</li></ul></li><li>内存地址寄存器（MAR）<ul><li>输入时，存放数据存放到内存的起始目的地址</li><li>输出时，存放内存源地址</li></ul></li><li>数据寄存器（DR）<ul><li>暂存I&#x2F;O设备到内存或者内存到设备的数据</li></ul></li><li>数据计数器（DC）<ul><li>存放传送字（节）数</li></ul></li></ul></li><li><strong>工作流程</strong><ul><li>CPU接收到设备的DMA请求时<ul><li>向DMA控制器发出命令，设置MAR和DC初值，启动DMA控制器，然后继续其他工作</li></ul></li><li>之后CPU将I&#x2F;O控制权交给DMA控制器，由DMA控制器负责数据传送<ul><li>DMA控制器直接和内存交互，每次传送一个字，不需要CPU参与</li></ul></li><li>整个数据传送结束后，DMA控制器向CPU发一个中断信号<ul><li>结束后才有中断，中断的作用是通知CPU</li></ul></li><li>只有传送开始和结束才有CPU参与</li></ul></li></ul></li></ul></li></ul><h3 id="I-O软件层次结构"><a href="#I-O软件层次结构" class="headerlink" title="I&#x2F;O软件层次结构"></a>I&#x2F;O软件层次结构</h3><ul><li><p>使复杂的I&#x2F;O软件具有清晰的结构 良好的可移植性和易适应性</p></li><li><p>每层利用下层提供的服务，完成I&#x2F;O中某些子功能，屏蔽实现细节，向高层提供服务</p></li></ul><p><img src="https://shingeki-pic.oss-cn-nanjing.aliyuncs.com/img/20250402111850103.png"></p><ul><li><p><strong>用户层软件</strong></p><ul><li>实现与用户交互的接口，用户可以直接调用在用户层提供的、与I&#x2F;O操作有关的库函数</li><li>大部分I&#x2F;O软件都在OS内核，但仍有一部分在用户层</li><li>用户层I&#x2F;O软件必须通过一组系统调用获取OS服务</li></ul></li><li><p><strong>设备独立性软件（20）</strong></p><ul><li>实现用户程序与设备驱动器的统一接口、设备命名、设备保护以及设备的分配与释放等</li><li>同时为设备管理和数据传送提供必要的存储空间</li><li><strong>设备独立性</strong><ul><li>也称<strong>设备无关性</strong></li><li>含义：应用程序所用的设备不局限于某个具体的物理设备</li><li>为了实现设备独立性，引入逻辑设备和物理设备的概念<ul><li>应用程序使用逻辑设备名请求使用某些设备</li><li>系统实际执行时，将逻辑设备名映射成物理设备名<ul><li>使用逻辑设备名的好处<ul><li>增加设备分配灵活性</li><li>易于实现I&#x2F;O重定向<ul><li>含义: 用于I&#x2F;O操作的设备可以更换，而不必改变应用程序</li></ul></li></ul></li></ul></li></ul></li></ul></li><li>设备独立性软件主要功能<ul><li>执行所有设备的公有操作，比如设备分配回收、逻辑设备名映射成物理设备名等</li><li>向用户层（文件层）提供统一接口，比如各种设备的读写统一使用read&#x2F;write命令</li></ul></li></ul></li><li><p><strong>设备驱动程序</strong></p><ul><li>与硬件直接相关，负责具体实现系统对设备发出的操作指令，驱动I&#x2F;O设备工作</li><li>每类设备配置一个驱动</li><li>驱动是<strong>I&#x2F;O进程和设备控制器之间的通信</strong>程序，通常以<strong>进程</strong>的形式存在</li><li>向上层用户程序提供一组标准接口</li><li>将设备控制器发来的信号传送给上层软件</li></ul></li><li><p><strong>中断处理程序</strong></p><ul><li>保存被中断进程的CPU环境，转入相应中断处理程序进行处理，处理完毕，恢复现场，返回原进程</li></ul></li><li><p><strong>磁盘I&#x2F;O操作中各层次的处理过程（以读操作为例）</strong></p><ul><li>用户读取某设备内容时，通过OS提供的read接口（<strong>用户层</strong>）</li><li>用户发出的read命令经过<strong>设备独立层</strong>进行解析，交给下层</li><li>不同类型设备对于read命令行为有所不同，需要针对不同设备解析成不同指令（<strong>设备驱动层</strong>）</li><li>解析完毕后，需要中断正在运行的进程，转而执行read命令（<strong>中断处理程序</strong>）</li><li>命令真正抵达硬件设备，硬件设备控制器按照命令操控硬件（<strong>硬件</strong>）</li></ul></li></ul><h3 id="应用程序I-O接口"><a href="#应用程序I-O接口" class="headerlink" title="应用程序I&#x2F;O接口"></a>应用程序I&#x2F;O接口</h3><p>指I&#x2F;O系统与高层（应该是应用层？）的接口</p><ul><li><p><strong>I&#x2F;O接口分类</strong></p><ul><li>字符设备接口<ul><li>get&#x2F;put操作<ul><li>字符设备不可寻址，只能顺序存取</li><li>通常建立一个字符缓冲区，用户程序通过get操作从缓冲区获取字符，put操作输入到缓冲区</li></ul></li><li>in-control指令<ul><li>通用指令，参数多，功能多</li></ul></li><li>字符设备都属于独占设备，还需要提供打开和关闭操作，实现互斥共享</li></ul></li><li>块设备接口</li><li>网络设备接口</li></ul></li><li><p>阻塞I&#x2F;O和非阻塞I&#x2F;O</p><ul><li>阻塞I&#x2F;O<ul><li>用户进程调用I&#x2F;O操作时，进程被阻塞</li><li>实现简单，适合并发量小</li><li>但可能一直被阻塞</li></ul></li><li>非阻塞I&#x2F;O<ul><li>不阻塞该进程，但进程需要轮询I&#x2F;O操作是否完成</li><li>I&#x2F;O执行阶段，进程可以做其他事情</li><li>适合并发量大的应用开发</li><li>但轮询会占用CPU时间</li></ul></li></ul></li></ul><h2 id="设备独立性软件"><a href="#设备独立性软件" class="headerlink" title="设备独立性软件"></a>设备独立性软件</h2><ul><li>定义见上I&#x2F;O软件层次结构部分</li></ul><h3 id="高速缓存和缓冲区"><a href="#高速缓存和缓冲区" class="headerlink" title="高速缓存和缓冲区"></a>高速缓存和缓冲区</h3><ul><li><p><strong>磁盘高速缓存（15）</strong></p><ul><li>OS中利用磁盘高速缓存提高磁盘I&#x2F;O速度</li><li>例如，正在运行进程的数据既存在硬盘上，也存在内存里以及CPU的二级、一级高速缓存里</li><li><strong>磁盘高速缓存技术与CPU和内存之间的小容量高速缓存器不同</strong><ul><li>指的是利用内存暂存磁盘中信息</li></ul></li><li>逻辑上属于磁盘，物理上是驻留在内存中的盘块</li><li>在内存中，有两种形式<ul><li>在内存中开辟一个单独的空间作为缓冲区，大小固定</li><li>将未利用的内存空间作为一个缓冲池，供请求分页系统和磁盘I&#x2F;O时共享</li></ul></li></ul></li><li><p><strong>缓冲区（11 13）</strong></p><ul><li>在设备管理中，引入缓冲区的目的<ul><li>缓和CPU和I&#x2F;O设备速度不匹配的矛盾</li><li>减少对CPU的中断频率，放宽对CPU中断响应时间的限制</li><li>解决基本数据单元大小（数据粒度）不匹配的问题</li><li>提高CPU和I&#x2F;O设备之间并行性</li></ul></li><li>缓冲区的实现<ul><li>硬件缓冲<ul><li>成本高，只有一些关键部位采用</li></ul></li><li>利用内存<ul><li><strong>单缓冲</strong><ul><li>每当用户进程发出一个I&#x2F;O请求，OS在内存中为之分配一个缓冲区</li><li>通常一个缓冲区大小就是一个块</li><li>块设备输入时<br><img src="https://shingeki-pic.oss-cn-nanjing.aliyuncs.com/img/20250402111857339.png"><ul><li>设从设备将一块数据输入到缓冲区的时间为 $T$</li><li>OS将缓冲区中数据传送到工作区的时间为 $M$</li><li>CPU对数据处理时间为 $C$</li><li>缓冲区装满后才能从缓冲区中取出数据</li></ul></li><li><strong>时间分析</strong><ul><li>$T$和 $C$<strong>可以并行</strong>（上一个块的 $C$和下一个块的 $T$）</li><li>$T&gt;C$时，CPU处理完一块数据后，暂时不能将下一块数据传到工作区，必须等缓冲区装满数据，再传送下一块，平均处理一块的时间为 $T+M$</li><li>$T&lt;C$时，缓冲区装满数据后，必须等CPU处理完上一块数据，才能传送到工作区，平均处理一块的时间为 $C+M$</li><li>所以平均处理一块的时间为 $max(C,T)+M$</li></ul></li></ul></li><li><strong>双缓冲（缓冲对换）</strong><ul><li>加快I&#x2F;O，提高设备利用率<br><img src="https://shingeki-pic.oss-cn-nanjing.aliyuncs.com/img/20250402111906146.png"></li><li>输入时，先输入到缓冲区1，装满后转向缓冲区2</li><li>此时OS可以从缓冲区1里取出数据，CPU开始处理</li><li>1中数据处理完后，若2已满，继续从2中取数据处理</li><li><strong>时间分析</strong><ul><li>$C$、$M$（上一块的）可以和$T$（下一块的）并行</li><li>$T&gt;C+M$时，设备输入的时间比传送和处理的时间长，设备可以连续输入<ul><li>分析：某时刻1空，2满，2传送数据，1装入数据。传输并处理的时间为 $C+M$，但此时1未满，必须等1装满。总时间为 $T$</li></ul></li><li>$T&lt;C+M$时，设备输入的时间比数据传送和处理的时间少，CPU不必等待设备输入<ul><li>分析：某时刻1空，2满，2传送数据，1装入数据。1装满用时 $T$，必须等2中数据传送、处理完之后，才能开始传送。总时间为 $C+M$</li></ul></li><li>每块平均时间 $max(C+M,T)$</li></ul></li><li>若两台机器之间仅配置单缓冲，则任意时刻都只能实现单方向数据传输<ul><li>为了实现双向数据传输，必须在两台机器中都设置两个缓冲区，一个用作发送缓冲区，一个用作接收缓冲区<br><img src="https://shingeki-pic.oss-cn-nanjing.aliyuncs.com/img/20250402111917342.png"></li></ul></li></ul></li><li><strong>循环缓冲</strong><ul><li>双缓冲机制中，输入输出速度基本匹配的时候，能取得较好效果</li><li>输入输出差别大时，引入多缓冲机制，<strong>让多个缓冲区组成循环缓冲区</strong></li><li>包含多个大小相等的缓冲区，每个缓冲区有一个指针指向下个缓冲区，链接成循环队列</li><li>循环缓冲中还需要设置in out两个指针<ul><li>in指向第一个可以输入数据的空缓冲区</li><li>out指向第一个可以提取数据的满缓冲区</li><li>输入&#x2F;输出时，in out指针沿链接方向移动</li></ul></li></ul></li><li><strong>缓冲池</strong><ul><li>缓冲区是一块内存空间，缓冲池是包含一个用于管理自身的数据结构和一组操作函数的管理机制</li><li>用于管理多个缓冲区</li><li>可供多个进程共享</li><li>缓冲池由多个系统公用的缓冲区组成<ul><li>缓冲区中有 空缓冲队列 输入队列 输出队列<ul><li>这些队列都是对应类型的缓冲区链接成的</li></ul></li><li>4种工作缓冲区<ul><li>收容输入数据的hin</li><li>提取输入数据的sin</li><li>收容输出的hout</li><li>提取输出的sout</li></ul></li><li>工作时从对应的队列队首取出缓冲区，操作完后插入相应的其他队列<br><img src="https://shingeki-pic.oss-cn-nanjing.aliyuncs.com/img/20250402111923373.png"></li></ul></li></ul></li></ul></li></ul></li></ul></li><li><p><strong>高速缓存和缓冲区对比</strong></p><ul><li>相同点<ul><li>两者都介于高速低速设备之间</li></ul></li><li>不同点<ul><li>存放数据<ul><li>高速缓存存放低速设备上某些数据的复制</li><li>缓冲区存放高速低速之间传递的数据</li></ul></li><li>目的<ul><li>高速缓存存放高速设备经常要访问的数据</li><li>高速设备和低速设备的通信都要经过缓冲区，不存在直接访问</li></ul></li></ul></li></ul></li></ul><h3 id="设备分配与回收"><a href="#设备分配与回收" class="headerlink" title="设备分配与回收"></a>设备分配与回收</h3><ul><li><p>设备分配是指根据用户的I&#x2F;O请求分配所需设备</p></li><li><p><strong>相关数据结构</strong></p><ul><li>系统中有多个通道，每个通道连接多个控制器，每个控制器连接多个物理设备，数据结构要求体现这种关系</li><li><strong>设备控制表（DCT）</strong><ul><li>系统为每个设备配置一个DCT，表项就是设备各个属性</li><li>应该包含 设备类型 设备标识符（物理设备名） 设备状态 指向控制器表的指针等</li></ul></li><li><strong>控制器控制表（COCT）</strong><ul><li>每个设备控制器对应一个COCT</li><li>表项有 与控制器连接的通道表指针</li></ul></li><li><strong>通道控制表（CHCT）</strong><ul><li>每个通道有一个CHCT</li><li>通过表项 与通道连接的控制器表首址 可以找到该通道管理的所有控制器的信息</li></ul></li><li><strong>系统设备表（SDT）</strong> <ul><li>整个系统只有一个SDT</li><li>记录系统中所有物理设备的情况</li></ul></li></ul></li><li><p><strong>设备分配时应该考虑的因素（23）</strong></p><ul><li>设备固有属性<ul><li>独占设备：分配给进程后，进程独占</li><li>共享设备：可以同时分配给多个，需要合理调度</li><li>虚拟设备：可共享，也可以同时分配给多个</li></ul></li><li>设备分配算法<ul><li>FCFS算法，根据进程提出请求的先后次序 排成队列</li><li>最高优先级优先</li></ul></li><li>安全性（防止死锁）<ul><li>安全分配方式<ul><li>进程发出I&#x2F;O请求后就进入阻塞态，直到I&#x2F;O操作完成再唤醒</li><li>设备分配安全</li><li>但CPU和I&#x2F;O设备串行工作</li></ul></li><li>不安全分配方式<ul><li>进程发出I&#x2F;O请求后仍然继续运行，需要时可能还会继续发出请求</li><li>仅当所请求的设备被其他进程占用，才进入阻塞态</li><li>一个进程可以同时操作多个设备</li><li>但可能死锁</li></ul></li></ul></li></ul></li><li><p><strong>设备分配的步骤</strong></p><ul><li>以<strong>独占设备</strong>为例</li><li><strong>分配设备</strong><ul><li>根据I&#x2F;O请求中的物理设备名，查找SDT，找到设备的DCT，获取设备状态<ul><li>若忙，将进程PCB挂到设备等待队列中</li><li>若不忙，根据一定策略分配</li></ul></li></ul></li><li><strong>分配控制器</strong><ul><li>设备分配后，根据DCT找到COCT，查询控制器状态<ul><li>若忙，将进程PCB挂到控制器等待队列中</li><li>若不忙，将控制器分配给该进程</li></ul></li></ul></li><li><strong>分配通道</strong><ul><li>控制器分配后，根据COCT找到CHCT，查询通道状态<ul><li>若忙，将进程PCB挂到通道等待队列</li><li>若不忙，将通道分配给进程</li></ul></li></ul></li><li>三者都分配成功后，设备分配才成功。之后可以启动设备传送数据</li><li>以上的设备分配过程使用物理设备名，<strong>不具有设备无关性</strong>。<ul><li>使用逻辑设备名时，系统从SDT中寻找第一个该类设备的DCT</li><li>若忙，则依次寻找该类设备</li><li>若都忙，再挂入等待队列</li></ul></li></ul></li><li><p><strong>逻辑设备名到物理设备名的映射（09）</strong></p><ul><li>在系统中配备一张逻辑设备表，将逻辑设备名映射为物理设备名</li><li><strong>逻辑设备表（LUT）</strong> 的每个表项包含逻辑设备名 物理设备名 设备驱动的入口地址</li><li>进程用逻辑设备名请求设备的时候<ul><li>系统分配一台相应物理设备</li><li>在LUT中建立一个条目，填上相应信息</li><li>以后进程再利用该逻辑设备名请求I&#x2F;O操作时，系统查找LUT寻找对应的物理设备和驱动</li></ul></li><li>LUT的两种方式<ul><li>整个系统只有一张<ul><li>所有用户不能使用相同逻辑设备名</li><li>适用于单用户系统</li></ul></li><li>每个用户一张</li></ul></li></ul></li></ul><h3 id="SPOOLing技术（假脱机技术）（16）"><a href="#SPOOLing技术（假脱机技术）（16）" class="headerlink" title="SPOOLing技术（假脱机技术）（16）"></a>SPOOLing技术（假脱机技术）（16）</h3><ul><li><p>为了缓和CPU的高速性和I&#x2F;O设备低速性的矛盾，引入假脱机技术</p><ul><li>GPT: <strong>脱机输入&#x2F;输出</strong>是指设备可以独立完成数据的输入或输出，而不需要一直依赖中央处理器（CPU）的控制。</li><li><strong>SPOOLing</strong> 模拟了这种脱机的方式，但实际上，设备并未真正脱离计算机，而是通过<strong>缓冲区</strong>或<strong>中间存储介质</strong>（通常是磁盘或内存）实现的。这就是为什么叫“假脱机”：系统中的外设看起来像是“脱机”处理输入&#x2F;输出任务，但实际上数据仍然通过计算机的调度进行管理。</li></ul></li><li><p>将独占设备改造成共享设备</p><ul><li>比如让多个进程认为自己占有打印机</li></ul></li></ul><p><img src="https://shingeki-pic.oss-cn-nanjing.aliyuncs.com/img/20250402111931330.png"></p><ul><li><p><strong>SPOOLing组成</strong></p><ul><li>输入井和输出井<ul><li>在磁盘上开辟出的两个存储区域</li><li>输入井模拟脱机输入时的磁盘，收容I&#x2F;O设备输入数据</li><li>输出井模拟脱机输出时的磁盘，用于收容用户程序输出数据</li><li>一个进程的输入（输出）数据保存为一个文件</li><li>所有进程的输入（输出）文件链接成一个队列</li></ul></li><li>输入缓冲区和输出缓冲区<ul><li>内存中的两个缓冲区</li><li>输入缓冲区暂存输入设备送来的数据，后面传送到输入井</li><li>输出缓冲区同理</li></ul></li><li>输入进程和输出进程<ul><li>输入进程模拟脱机输入时的外围控制机，将数据从输入设备传送到输入缓冲区，再放到输入井<ul><li>GPT: <strong>外围控制机</strong>（Peripheral Control Unit），有时也称为<strong>通道控制器</strong>或<strong>外围处理器</strong>，是一种用于管理输入&#x2F;输出设备操作的专用硬件设备。它的主要功能是负责处理外围设备的输入或输出请求，而无需中央处理器（CPU）直接参与这些操作。</li></ul></li><li>输出进程将数据从内存传送到输出井，输出设备空闲时，将输出井中数据经缓冲区输出到设备</li></ul></li><li>井管理程序<ul><li>控制作业和磁盘井之间信息交换</li></ul></li></ul></li><li><p>以独占设备打印机为例</p><ul><li>多个用户进程发出打印输出请求时，SPOOLing系统同意它们的请求</li><li>假脱机管理进程为每个进程做两项工作<ul><li>在磁盘缓冲区为进程申请一个空闲盘块，将要打印的数据送入其中暂存</li><li>为进程申请一张空白的用户请求打印表，将用户打印要求填入其中，再将该表挂到假脱机文件队列上</li></ul></li><li>对每个用户进程而言，系统没有真正打印，只是将数据输出到缓冲区。</li><li>真正打印是在打印机空闲且打印任务在等待队列的队首</li><li>系统为进程分配缓冲区，相当于分配了一个逻辑设备，使每个进程认为自己独占了打印机，实现了共享</li></ul></li><li><p><strong>SPOOLing特点</strong></p><ul><li>提高I&#x2F;O速度，将对低速I&#x2F;O设备的操作变为对磁盘缓冲区中数据的存取</li><li>独占设备改造为共享设备</li><li>实现虚拟设备功能，对于每个进程，它们都认为自己独占设备</li></ul></li></ul><h3 id="设备驱动程序接口"><a href="#设备驱动程序接口" class="headerlink" title="设备驱动程序接口"></a>设备驱动程序接口</h3><ul><li><p>设备驱动程序是I&#x2F;O系统上层与设备控制器之间的通信程序</p></li><li><p>主要任务是接收上层应用的抽象I&#x2F;O请求 比如read&#x2F;write，转换为具体要求后发给设备控制器</p></li><li><p>也能将设备控制器发来的信号传给上层应用</p></li><li><p><strong>应该具有的功能（13 19 23）</strong></p><ul><li>接收上层软件发来的命令和参数，并转换为设备具体要求</li><li>检查用户I&#x2F;O请求合法性</li><li>了解设备工作状态</li><li>传递设备操作相关参数</li><li>设置设备工作方式</li><li>发出I&#x2F;O命令<ul><li>若设备空闲，立即启动</li><li>否则将请求者PCB挂到等待队列</li></ul></li><li>及时响应设备控制器发来的中断请求，调用相应中断处理程序</li></ul></li><li><p><strong>设备驱动程序特点（22）</strong></p><ul><li>与设备采用的I&#x2F;O控制方式密切相关</li><li>与硬件密切相关，对于不同类型设备，应该有不同的驱动</li><li>很多驱动的基本部分已经固化在ROM</li><li>驱动应该允许同时多次调用执行</li></ul></li></ul><h3 id="磁盘和固态硬盘"><a href="#磁盘和固态硬盘" class="headerlink" title="磁盘和固态硬盘"></a>磁盘和固态硬盘</h3><h3 id="磁盘（19）"><a href="#磁盘（19）" class="headerlink" title="磁盘（19）"></a>磁盘（19）</h3><ul><li><p>有一个称为磁头的导体线圈存取数据</p><ul><li>读写期间，磁头固定，磁盘高速旋转</li></ul></li><li><p>磁盘盘面上的数据存在一组同心圆中，称为磁道</p><ul><li>每个磁道和磁头一样宽</li><li>一个盘面有上千个磁道</li></ul></li><li><p>磁道划分为几百个扇区，每个扇区固定存储大小（如1KB）</p><ul><li>一个扇区称为一个盘块</li><li>扇区按照固定圆心角度划分<ul><li>每个磁道划分为相同数目的扇区</li><li>扇区大小固定，所以密度从最外道向内增加</li><li>磁盘存储能力受限于最内道的最大记录密度</li><li>现代磁盘为了充分利用外层磁道存储能力<ul><li>将盘面分为若干环带，同一环带内的所有磁道具有相同的扇区数</li><li>外层环带的磁道比内层扇区更多</li></ul></li></ul></li></ul></li><li><p>相邻磁道和扇区通过一定间隙隔开，防止精度错误</p></li></ul><p><img src="https://shingeki-pic.oss-cn-nanjing.aliyuncs.com/img/20250402111939519.png"></p><ul><li><p>多个盘面堆叠，组成磁盘组</p><ul><li>每个盘面对应一个磁头，所有磁头固定，与磁盘中心距离相同</li><li><strong>所有盘面上相对位置相同的磁道组成柱面（相当于圆柱壁）</strong></li></ul></li><li><p>扇区是磁盘可寻址的最小单位</p></li><li><p>磁盘上能存储的物理块数目由 扇区数 磁道数 磁盘面数决定</p><ul><li>这种分割是将磁盘拆分为多个盘 每个盘继续拆分为多个磁道 磁道拆分为扇区</li></ul></li><li><p><strong>磁盘地址用 柱面号 盘面号 扇区号 表示</strong></p><ul><li>这种分割将磁盘纵向拆分为多个柱面，每个柱面按盘面数横向拆分为多个磁道，磁道拆分为扇区</li></ul></li></ul><h3 id="磁盘的管理"><a href="#磁盘的管理" class="headerlink" title="磁盘的管理"></a>磁盘的管理</h3><ul><li><p><strong>磁盘初始化</strong></p><ul><li>低级格式化（物理格式化）<ul><li>在磁盘可以存储数据之前，必须将它分成扇区，以便磁盘控制器进行读写</li><li>每个扇区由头部 数据区域和尾部组成<ul><li>头部尾部包含一些磁盘控制器的使用信息<ul><li>利用磁道号 磁头号 扇区号标志一个扇区</li><li>利用CRC字段对扇区进行校验</li></ul></li></ul></li></ul></li></ul></li><li><p><strong>分区</strong></p><ul><li>在磁盘存储文件之前，还需要两个步骤<ul><li><strong>将磁盘分区</strong><ul><li>每个分区由一个或者多个柱面组成</li><li>每个分区的起始扇区和大小都记录在磁盘主引导记录的分区表中</li></ul></li><li><strong>对物理分区逻辑格式化（高级格式化）（17 21）</strong><ul><li>将初始文件系统数据结构存储到磁盘上<ul><li>包括空闲空间和已分配空间 初始为空的目录</li></ul></li></ul></li></ul></li><li>扇区单位太小，OS将多个相邻扇区组合在一起，形成一簇（Linux中称为块）<ul><li>一簇只能存放一个文件的内容，文件所占空间只能是簇的整数倍</li><li>0字节的文件也占一簇</li></ul></li></ul></li><li><p><strong>引导块</strong></p><ul><li>计算机启动时运行一个初始化程序（自举程序），初始化CPU 寄存器 设备控制器 内存等，然后启动OS<ul><li>自举程序需要找到磁盘上的OS内核，加载到内存，并转到起始地址</li><li>GPT: 自举的含义：bootstrap，自己拉自己脱离泥沼</li></ul></li><li>自举程序通常存放在ROM中<ul><li>为了避免改变自举代码而需要改变ROM硬件的问题<ul><li>通常ROM中只保留很小的自举装入程序</li><li>完整功能的引导程序保存在磁盘启动块上<ul><li>启动块位于磁盘固定位置</li></ul></li></ul></li><li>引导ROM中的代码指示磁盘控制器将引导块读入内存，然后开始执行<ul><li>它可以从非固定的磁盘位置加载整个OS</li></ul></li></ul></li><li>Windows引导过程<ul><li>磁盘分为多个分区，有一个引导分区<ul><li>引导分区包含OS和驱动</li></ul></li><li>引导代码存在磁盘0号扇区，称为主引导记录（MBR）<ul><li>MBR还包含一个磁盘分区表和一个标志（指示从哪个分区引导系统）</li></ul></li><li>系统找到引导分区时，读取第一个扇区（引导扇区），开始加载各种系统服务</li></ul></li></ul></li><li><p><strong>坏块</strong></p><ul><li>简单磁盘的坏块可以手动处理<ul><li>比如MS-DOS的逻辑格式化会扫描磁盘检查坏块，在FAT表上标出来</li></ul></li><li>复杂的磁盘中，控制器维护磁盘内坏块列表<ul><li>控制器可以采用备用块逻辑地替代坏块</li></ul></li></ul></li></ul><h3 id="磁盘调度算法"><a href="#磁盘调度算法" class="headerlink" title="磁盘调度算法"></a>磁盘调度算法</h3><ul><li><p><strong>磁盘存取时间</strong></p><ul><li>一次磁盘读写的时间由寻道时间、旋转延迟时间、传输时间决定</li><li><strong>寻道时间</strong><ul><li>活动头磁盘在读写之前，将磁头移动到目的磁道所需时间</li><li>m是与磁盘驱动器速度有关的常数 跨越n条磁道，启动磁头臂时间s</li><li>$$T_s&#x3D;m×n＋s$$</li></ul></li><li><strong>旋转延迟时间</strong><ul><li>磁头定位到要读写的扇区所需时间</li><li>设旋转速度为r</li><li>$$T_r＝\frac{1}{2r}$$</li><li>取了平均值，相当于转一圈所需时间的一半</li></ul></li><li><strong>传输时间</strong><ul><li>从磁盘读出或者向磁盘写入数据所需时间</li><li>读&#x2F;写字节数b，磁盘旋转速度r，一个磁道上字节数N</li><li>$$T_t＝\frac{b}{rN}$$</li></ul></li><li>总时间为上面三者之和</li></ul></li><li><p><strong>磁盘调度算法（09 10 15 18 19 21 24）</strong></p><ul><li>磁盘存取时间中，寻道时间占比最大，与磁盘调度算法密切相关</li><li>调度的主要目标是减少磁盘平均寻道时间</li><li><strong>FCFS算法</strong><ul><li>根据请求访问磁盘的先后顺序进行调度</li></ul></li><li><strong>最短寻道时间优先（SSTF）算法</strong><ul><li>每次选择与当前磁头最近的磁道</li><li>可能出现饥饿现象</li></ul></li><li><strong>扫描（SCAN）算法（电梯调度算法）</strong><ul><li>防止SSTF中产生的饥饿（磁头在小范围内来回移动，不能到达远处）</li><li>规定磁头移动到最外侧时才能向内，移动到最内侧时才能向外</li><li>也就是在SSTF的基础上规定了磁头移动的方向</li><li>SCAN算法对最近扫描过的区域不公平，访问局部性不如FCFS和SSTF</li><li>偏向于处理靠内或者靠外的请求</li></ul></li><li><strong>循环扫描（C-SCAN）算法</strong><ul><li>在SCAN算法的基础上<ul><li>磁头返回时直接移动到起始端，不服务任何请求</li></ul></li><li>消除对两端磁道请求的不公平</li></ul></li><li><strong>LOOK和C-LOOK</strong><ul><li>SCAN和C-SCAN的基础上<ul><li>磁头只需要移动到最远端的请求就可以返回，不需要到达磁盘端点</li></ul></li></ul></li></ul></li><li><p><strong>减少延迟时间的方法</strong></p><ul><li>交替编号（扇区）<ul><li>磁盘是连续自转设备，磁头读入一个扇区后，需要短暂处理时间，才能读下一个扇区</li><li>若逻辑上相邻的块在物理上也相邻，则读入几个连续的逻辑块可能需要很长延迟</li><li>所以对一个盘面的扇区交替编号</li></ul></li><li>错位命名（不同盘面的扇区）<ul><li>逻辑块在相同柱面上按盘面号连续存放<ul><li>0号盘0扇区 0号盘1扇区……0号盘7扇区 1号盘0扇区……的顺序</li><li>要读入不同盘面上的连续块，在读完0号盘7扇区后，需要一段处理时间<ul><li>此时磁头划过1号盘0扇区并不能读取，与上面同理</li></ul></li></ul></li><li>所以对不同的盘面错位命名<ul><li>也就是相同柱面上不同盘面的<strong>扇区编号错位</strong></li></ul></li></ul></li></ul></li><li><p><strong>提高磁盘I&#x2F;O速度的方法（12 18）</strong></p><ul><li>采用磁盘高速缓存</li><li>调整磁盘请求顺序<ul><li>即上面的调度算法</li></ul></li><li>提前读<ul><li>读磁盘当前块时，将下一磁盘块也读入内存缓冲区</li></ul></li><li>延迟写<ul><li>仅在缓冲区首部设置延迟写标志，然后释放此缓冲区并将其链入空闲缓冲区链表尾部</li><li>当其他进程申请到此缓冲区的时候，才真正将缓冲区信息写入磁盘块<ul><li>GPT: 写入触发条件<ul><li>缓冲区达到容量上限</li><li>定时触发</li><li>系统关机、卸载文件系统</li></ul></li></ul></li><li>GPT: 允许多个写操作在内存中进行聚合，减少对磁盘的频繁写操作</li></ul></li><li>优化物理块分布<ul><li>上面的扇区编号优化</li><li>文件采用链接方式和索引方式组织时<ul><li>尽量将同一个文件的盘块安排在一个磁道上或者相邻磁道上，减少寻道时间</li></ul></li><li>将若干盘块组成簇，按簇对文件分配，也可以减少磁头平均移动距离</li></ul></li><li>虚拟盘<ul><li>用内存空间仿真磁盘，又叫RAM盘</li><li>常用于存放临时文件</li></ul></li><li>采用磁盘阵列RAID<ul><li>由于可以采用并行交叉存取，因此能大幅提高I&#x2F;O速度</li></ul></li></ul></li></ul><h3 id="固态硬盘（SSD）"><a href="#固态硬盘（SSD）" class="headerlink" title="固态硬盘（SSD）"></a>固态硬盘（SSD）</h3><ul><li><p><strong>固态硬盘特性</strong></p><ul><li>基于闪存技术</li><li>由一个或多个闪存芯片和闪存翻译层组成<ul><li>闪存芯片代替传统磁盘的机械驱动器</li><li>闪存翻译层将来自CPU的逻辑块读、写请求翻译成对底层物理设备的控制信号，相当于磁盘控制器</li><li>一个闪存由多个块组成，每块由多个页组成<ul><li>数据以页为单位读写</li><li>只有一页所属的块整个被擦除后，才能写这一页</li><li>某个块多次写后就会损坏</li></ul></li></ul></li></ul></li><li><p><strong>磨损均衡</strong></p><ul><li>闪存擦写寿命有限，且一部分闪存损坏会导致整个SSD的损坏<ul><li>所以需要磨损均衡</li></ul></li><li>动态磨损均衡<ul><li>写入数据时，自动选择较新的闪存块</li></ul></li><li>静态磨损均衡<ul><li>SSD检测并自动进行数据分配，老闪存块承担无须写的存储任务，新闪存块腾出空间</li><li>平常读写在新闪存块中</li></ul></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
            <tag> OS </tag>
            
            <tag> 考研 </tag>
            
            <tag> I/O管理 </tag>
            
            <tag> I/O </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>王道OS看书笔记——文件管理</title>
      <link href="/2025/03/31/OS-learning-3/"/>
      <url>/2025/03/31/OS-learning-3/</url>
      
        <content type="html"><![CDATA[<p>本文为我考研期间看王道书时写的飞书笔记，根据各知识点的逻辑关系进行整理，添加了一点自己的理解，内容不如王道书全。</p><h2 id="文件系统基础"><a href="#文件系统基础" class="headerlink" title="文件系统基础"></a>文件系统基础</h2><h3 id="文件控制块和索引节点"><a href="#文件控制块和索引节点" class="headerlink" title="文件控制块和索引节点"></a>文件控制块和索引节点</h3><ul><li><p><strong>文件控制块（FCB）（09）</strong></p><ul><li>存放控制文件所需的各种信息</li><li>实现按名存取</li><li>FCB 的有序集合称为文件目录，一个 FCB 就是一个文件目录项</li><li>主要包括<ul><li>基本信息：文件名 文件物理位置 文件逻辑结构 文件物理结构</li><li>存取控制信息：文件主、核准用户、一般用户的存取权限</li><li>使用信息：上次修改时间等</li></ul></li></ul></li><li><p><strong>索引节点（18 20 22）</strong></p><ul><li>检索过程中只用到文件名</li><li>有的系统（如 UNIX）将文件名和文件描述信息分离，文件描述信息单独形成<strong>索引节点</strong></li><li>简称 i 结点</li><li>FCB&#x2F;索引节点和文件查找<ul><li>假设一个 FCB 为 64B，盘块大小 1KB，每个盘块中可以存放 16 个 FCB（FCB 必须连续存放）</li><li>若一个文件目录有 640 个 FCB，查找文件平均需要启动磁盘 20 次</li><li>UNIX 系统中，一个目录项 16B，14B 文件名，2B 索引节点号，1KB 盘块可以放 64 个目录项</li><li>查找文件平均启动磁盘次数降为 1&#x2F;4</li></ul></li><li>磁盘索引节点<ul><li>存放在磁盘上的索引节点，每个文件唯一</li><li>包括文件主标识符 文件类型 存取权限 物理地址等</li></ul></li><li>内存索引节点<ul><li>文件被打开时，将磁盘 inode 复制到内存中</li><li>增加了索引节点号 状态 访问计数等</li></ul></li></ul></li></ul><h3 id="文件的操作"><a href="#文件的操作" class="headerlink" title="文件的操作"></a>文件的操作</h3><ul><li><p><strong>文件的基本操作（13 21）</strong></p><ul><li><strong>创建文件</strong><ul><li>两个必要步骤<ul><li>为新文件分配外存空间</li><li>在目录中为之创建目录项<ul><li>目录项记录了新文件名 文件在外存中地址等信息</li></ul></li></ul></li></ul></li><li><strong>删除文件</strong><ul><li>根据文件名查找目录</li><li>删除文件对应目录项和 FCB</li><li>回收存储空间（磁盘空间和内存缓冲区）<ul><li>GPT: 文件数据缓冲区的作用是优化文件读写操作的效率，减少对硬盘等存储设备的频繁访问，同时提升系统的性能和资源利用率。由于存储设备的访问速度远低于内存的访问速度，缓冲区机制通过将数据暂时存放在内存中，减少对硬盘的直接读写请求，优化了系统性能。</li></ul></li></ul></li><li><strong>读文件</strong><ul><li>根据文件名查找目录</li><li>找到目录项，读出文件在外存中地址，利用其中读指针进行读操作</li></ul></li><li><strong>写文件</strong><ul><li>根据文件名查找目录</li><li>找到目录项，利用其中写指针对文件进行写操作</li></ul></li></ul></li><li><p><strong>文件的打开和关闭（14 17 20 21 23 24）</strong></p><ul><li><strong>文件打开和关闭的过程</strong><ul><li>利用系统调用 open</li><li>系统维护一个包含所有打开文件的表 称为<strong>打开文件表</strong></li><li>系统检索到指定文件的目录项后，将该目录项从外存复制到内存的打开文件表的一个表目中，并将该表目的索引号（<strong>文件描述符</strong>）返回给用户</li><li>用户再次对文件发出操作请求的时候，可以通过<strong>文件描述符</strong>在<strong>打开文件表</strong>中找到文件信息，节省检索开销</li><li>文件不再使用时，用系统调用 close 关闭，系统会从打开文件表中删除该表目</li></ul></li><li><strong>多进程打开文件的分析</strong><ul><li>采用两级表 整个系统表和每个进程表</li><li><strong>整个系统的打开文件表</strong>包含与进程无关的信息<ul><li>比如文件在磁盘的位置 文件大小等</li></ul></li><li><strong>每个进程的打开文件表</strong>保存进程对文件的使用信息<ul><li>比如文件当前读写指针 文件访问权限 指向系统表中适当条目的指针</li></ul></li><li>有进程打开文件，系统表包含该文件条目；另一进程打开后，只在自己的打开文件表中增加一个条目，指向系统表的相应条目</li><li>系统为每个文件关联一个打开计数器，记录多少进程打开文件<br><img src="https://shingeki-pic.oss-cn-nanjing.aliyuncs.com/img/20250402111443956.png"></li></ul></li><li><strong>文件名和文件描述符的应用场景</strong><ul><li>只要完成了 open()系统调用，后面的 read() write() Lseek() close()等文件操作的系统调用<strong>只涉及文件描述符</strong>，不涉及文件名</li><li>每个打开文件都有如下关联信息：、<ul><li>文件指针<ul><li>系统跟踪上次的读写位置作为当前文件位置的指针，这种指针对于打开文件的某进程唯一，所以需要和磁盘文件属性分开保存</li></ul></li><li>文件打开计数</li><li>文件磁盘位置</li><li>访问权限</li></ul></li></ul></li></ul></li></ul><h3 id="文件保护"><a href="#文件保护" class="headerlink" title="文件保护"></a>文件保护</h3><ul><li><p>口令保护 加密保护 访问控制</p></li><li><p>访问类型</p><ul><li>读 写 执行 添加（新信息添加到文件结尾） 删除 列表清单</li></ul></li><li><p><strong>访问控制（17）</strong></p><ul><li>实现访问控制，最简单的方法是对用户身份进行控制</li><li>为每个文件和目录增加一个访问控制列表（Access-Control List, ACL），规定每个用户名及其所允许的访问类型<ul><li>可以使用复杂的访问方法</li><li>长度无法预计，可能导致复杂的空间管理<ul><li>用精简的访问列表解决这个问题</li></ul></li><li><strong>精简 ACL 结构</strong><ul><li>拥有者：创建文件的用户</li><li>组：一组需要共享文件且具有类似访问的用户</li><li>其他<br><img src="https://shingeki-pic.oss-cn-nanjing.aliyuncs.com/img/20250402111459912.jpg"></li></ul></li></ul></li><li>口令和密码是另外两种访问控制方法<ul><li>口令<ul><li>用户在建立文件时提供一个口令</li><li>系统建立 FCB 时附上相应口令，同时告诉允许共享文件的其他用户</li><li>用户请求访问必须提供口令</li><li>时间空间开销小 但口令存在系统内部 不安全</li></ul></li><li>密码<ul><li>用户对文件加密，访问需要使用密钥</li><li>保密性强，节省存储</li></ul></li></ul></li></ul></li></ul><h3 id="文件的逻辑结构"><a href="#文件的逻辑结构" class="headerlink" title="文件的逻辑结构"></a>文件的逻辑结构</h3><ul><li><p>文件的逻辑结构指的是<strong>用户角度出发</strong>看到的文件的组织形式</p></li><li><p>文件的物理结构（存储结构）是指文件在外存的存储组织形式</p></li><li><p><strong>无结构文件（流式文件）</strong></p><ul><li>字符流组成</li><li>用读写指针指出下一个访问的字节</li><li>源程序、可执行文件、库函数都是无结构文件</li></ul></li><li><p><strong>有结构文件（记录式文件）</strong></p><ul><li>由一个以上的记录组成</li><li>GPT 举例：CSV JSON XML</li><li>各记录由相同或不同数目的数据项组成</li><li>记录可能定长 可能变长</li><li>按记录的组织形式分类<ul><li><strong>顺序文件</strong><ul><li>文件中记录按顺序排列</li><li>记录排列按时间顺序或者关键字顺序</li><li>对于批量操作高效</li><li>对于单个记录的处理 性能较差</li></ul></li><li><strong>索引文件</strong><ul><li>建立索引表，为每个记录设置索引表项，包含记录的指针和记录长度</li><li>加快检索，增加了存储开销</li></ul></li><li><strong>索引顺序文件</strong><ul><li>前两者结合</li><li>将变长记录顺序文件中所有记录分为若干组，然后建立一张索引表</li><li>为每组第一个记录简易索引项，包含该记录关键字和记录的指针</li><li>速度分析<ul><li>对于含有 N 条记录的顺序文件，查找记录平均 $\frac{N}{2}$次</li><li>对于索引顺序文件，假设分为 $\sqrt{N}$组，索引表中 $\sqrt{N}$个表项，每组 $\sqrt{N}$个记录<ul><li>先找索引表，需要 $\frac{\sqrt{N}}{2}$次</li><li>然后在组中找，需要  $\frac{\sqrt{N}}{2}$次</li><li>一共 $\sqrt{N}$次，提高了查找效率</li></ul></li><li>如果记录数很多，可以采用两级或者多级索引</li></ul></li><li><strong>直接文件或散列文件</strong><ul><li>给定记录的键值或者通过散列函数转换的键值直接决定记录的物理地址</li><li>很高的存取速度 但散列函数值可能冲突</li></ul></li></ul></li></ul></li></ul></li></ul><h3 id="文件的物理结构"><a href="#文件的物理结构" class="headerlink" title="文件的物理结构"></a>文件的物理结构</h3><ul><li><p>文件分配对应于文件的物理结构，是指如何为文件分配磁盘块</p><ul><li>常见的文件分配方法（09 11 13 20 考对比）<ul><li>连续分配</li><li>连接分配</li><li>索引分配</li></ul></li></ul></li><li><p><strong>连续分配（11 12 14）</strong></p><ul><li>每个文件在磁盘上占有一组连续的块<br><img src="https://shingeki-pic.oss-cn-nanjing.aliyuncs.com/img/20250402111509872.png"></li><li>进程访问磁盘时需要的寻道数和寻道时间最小</li><li>逻辑文件中的记录顺序存储在相邻的物理块中</li><li>一个文件的目录项中应该记录该文件的第一个磁盘块的块号和占用的块数</li><li><strong>优点</strong><ul><li>支持顺序访问和直接访问</li><li>顺序访问容易且速度快<ul><li>文件所占用的块可能位于一条或几条相邻的磁道上，磁头的移动距离最小</li></ul></li></ul></li><li><strong>缺点</strong><ul><li>要为一个文件分配连续的存储空间 会产生很多外部碎片<ul><li>和内存分配类似</li></ul></li><li>必须事先知道文件长度，且无法满足文件动态增长的要求<ul><li>文件长度的增长会覆盖物理上相邻的文件</li></ul></li><li>为了保证文件有序性，删除和插入记录的时候需要移动相邻记录</li></ul></li></ul></li><li><p><strong>链接分配（14 17 18 19）</strong></p><ul><li>离散分配</li><li><strong>优点</strong><ul><li>消除了磁盘的外部碎片，提高磁盘利用率</li><li>便于动态地为文件分配盘块，无需事先知道大小</li><li>文件插入 删除 修改方便</li></ul></li><li>分类<ul><li><strong>隐式链接</strong><ul><li>目录项中含有文件第一块的指针（盘块号）和最后一块的指针</li><li>每个文件对应一个磁盘块的链表</li><li>除最后一个盘块，其他都有指向下个盘块的指针<ul><li>这些指针对用户透明</li></ul></li><li><strong>缺点</strong><ul><li>只支持<strong>顺序访问</strong>，随机访问效率低</li><li><strong>稳定性低</strong>，若有一个指针出问题，都会导致文件数据丢失</li><li>指向下个盘块的指针耗费存储</li></ul></li><li>为了<strong>提高查找速度、减少指针占用空间</strong>，可以将几个盘块组成一个<strong>簇</strong>，按簇而不是块分配<ul><li>大幅减少查找时间<ul><li>改善许多算法的磁盘访问时间</li><li>指针占用空间比例降低</li><li>但<strong>增加了内部碎片</strong><br><img src="https://shingeki-pic.oss-cn-nanjing.aliyuncs.com/img/20250402111516755.png"></li></ul></li></ul></li></ul></li><li><strong>显式链接</strong><ul><li>将用于链接文件各物理块的指针，显式地存放在内存的链接表中<ul><li>称为<strong>文件分配表（File Allocation Table, FAT）</strong></li><li>每个表项存放指向下个盘块的指针</li><li>文件目录中记录文件起始块号，后续块号查表获得</li><li>FAT用-1表示文件最后一块</li><li>用-2（或其他）表示磁盘块空闲<ul><li>因此OS可以通过FAT对磁盘空闲空间进行管理</li></ul></li></ul></li><li><strong>优点</strong><ul><li>支持顺序访问，也支持直接访问</li><li>FAT在系统启动时就读入内存，检索记录在内存中进行，提高检索速度，减少磁盘访问次数</li></ul></li><li><strong>缺点</strong><ul><li>占用一定内存空间<br><img src="https://shingeki-pic.oss-cn-nanjing.aliyuncs.com/img/20250402111526055.png"></li></ul></li></ul></li></ul></li></ul></li></ul><blockquote><p>来源 CSDN:<br>簇&#x2F;块 是操作系统读写文件的基本单位。<br>磁盘读写基本单位是扇区。操作系统是通过块和簇来做为单位读取等操作数据的。<br>扇区是磁盘最小的物理存储单元，是磁头从磁盘中读取数据的最小单位（一般 512B），即磁头每次从磁盘中读取数据，都是一个扇区一个扇区读的。但由于操作系统无法对数目众多的扇区进行寻址，所以操作系统就将相邻的扇区组合在一起形成一个簇，然后再对簇进行管理(每个簇可以包括 2、4、8、16、 32 或 64 个扇区。)<br>块（簇）是 操作系统与磁盘（硬盘）交互的最小数据单元（在 linux 系统中称为块，在 windows 系统中称为簇）。操作系统从硬盘中拿一块数据，即完成一次磁盘 IO<br>文件系统就是操作系统的一部分，所以文件系统操作文件的最小单位是块和簇。</p></blockquote><ul><li><strong>索引分配（10 12 13 15 18 22）</strong><ul><li>打开文件时，只需要将文件对应盘块编号调入内存，而不是整个FAT</li><li>为此，应该将文件所有盘号集中，访问到某文件时，将文件对应盘块号一起调入内存</li><li>索引分配为每个文件分配一个索引块（表），将分配给该文件的所有盘块号都记录在索引块中</li><li><strong>优点</strong><ul><li>支持直接访问，当要访问第i块的时候，索引块的第i个条目指向的就是文件的第i个块</li><li>不会产生外部碎片</li></ul></li><li><strong>缺点</strong><ul><li>索引块增加了存储开销</li><li>文件很小时，分配一个索引块，索引块的利用率低</li><li>文件很大，可能需要占用多个索引块。此时可以利用指针链接起来，但低效</li></ul></li><li><strong>单级索引分配方式</strong><ul><li>假设盘块大小4KB，一个盘块号4B，则一个索引块中有1024个盘块号<ul><li>若采用单级索引，支持的最大文件为1024*4KB&#x3D;4MB<br><img src="https://shingeki-pic.oss-cn-nanjing.aliyuncs.com/img/20250402111537578.png"></li></ul></li></ul></li><li><strong>多级索引分配方式</strong><ul><li>原理类似多级页表</li><li>文件太大，索引块太多时，为索引块再建立一级索引，称为主索引</li><li>将第一个索引块、第二个索引块……的盘块号填入主索引表</li><li>查找时，通过主索引找二级索引，再找数据块</li><li>假设盘块大小4KB 每个盘块号4B 一个索引号中可以放1024个盘块号<ul><li>若采用两级索引，支持的最大文件1024<em>1024</em>4KB&#x3D;4GB</li></ul></li><li><strong>优点</strong><ul><li>极大加快对大型文件的查找速度</li></ul></li><li><strong>缺点</strong><ul><li>访问一个盘块时，需要启动磁盘的次数随着索引级数增加而增多，对小文件也是如此</li></ul></li></ul></li><li><strong>混合索引分配方式</strong><ul><li>对于小文件，为了提高访问速度，最好将盘块地址直接放入FCB，此为<strong>直接寻址</strong></li><li>对于中型文件，采用单级索引分配，先从FCB找到索引表，然后找到盘块地址，此为<strong>一次间址</strong></li><li>对于大型&#x2F;特大型文件，可以采用二级&#x2F;三级索引</li><li><strong>UNIX系统采用</strong></li><li>索引节点中，有<strong>13个地址项 i.addr(0) ~ i.addr(12)</strong><ul><li><strong>i.addr(0) ~ i.addr(9)存放直接地址</strong>，即文件数据块的盘块号<ul><li>若每个盘块大小4KB，文件不大于40KB时，可以直接从索引节点中读出所有盘块号</li></ul></li><li><strong>i.addr(10)提供一次间接地址</strong><ul><li>一次间接地址块中存放1024个盘块号，可以表示1K*4KB&#x3D;4MB大小的文件</li><li>同时采用直接地址和一次间接地址，最大文件长度4MB+4KB</li></ul></li><li>i.addr(11)提供二次间接地址<ul><li>可以表示4GB+4MB+40KB大小</li><li>i.addr(12)同理<br><img src="https://shingeki-pic.oss-cn-nanjing.aliyuncs.com/img/20250402111546984.png"></li></ul></li></ul></li></ul></li></ul></li></ul><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li><p>FCB的有序集合称为文件目录，一个FCB就是一个文件目录项</p></li><li><p>目录管理要求实现按名存取</p></li></ul><h3 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h3><ul><li><p>单级目录结构</p><ul><li>整个文件系统只有一张目录表，一个文件占一个目录项</li></ul></li><li><p>两级目录结构</p><ul><li>文件目录分为主文件目录和用户文件目录</li><li>主文件目录项记录用户名和相应用户文件所在存储位置</li><li>用户文件目录项记录该用户所有文件的FCB</li></ul></li><li><p><strong>树形目录结构</strong></p><ul><li>文件路径是个字符串</li><li>从根目录出发的是绝对路径</li><li>为每个进程设置一个当前目录（工作目录）</li></ul></li><li><p>无环图目录结构</p><ul><li><strong>树形目录结构</strong>便于文件分类，<strong>不便于共享</strong></li><li>在树形目录结构基础上增加一些指向同一节点的有向边，整个目录成为有向无环图</li><li>允许共享子目录或者文件，同一个文件或者子目录可以出现在多个目录中<br><img src="https://shingeki-pic.oss-cn-nanjing.aliyuncs.com/img/20250402111555085.png"></li></ul></li></ul><h3 id="文件共享"><a href="#文件共享" class="headerlink" title="文件共享"></a>文件共享</h3><ul><li><p><strong>基于索引节点的共享方式（硬链接）（09 17）</strong></p><ul><li>文件的物理地址和属性等信息不再放在目录项中，而是放在索引节点里面</li><li>文件目录中只设置文件名和指向索引节点的指针</li><li>索引节点中有一个<strong>链接计数（引用计数）</strong></li><li>Count &#x3D; 0，才能删除，否则只能count–</li><li>文件的所有者（创建者）在count!&#x3D;0时也不能删除<br><img src="https://shingeki-pic.oss-cn-nanjing.aliyuncs.com/img/20250402111604321.png"></li></ul></li><li><p><strong>利用符号链实现文件共享（符号链接）（软链接）（21）</strong></p><ul><li>为了使用户B共享用户A的一个文件F：<ul><li>系统创建一个LINK类型的新文件L，将L写入B的目录</li><li>L中只含有被链接文件F的路径</li></ul></li><li>只有文件主拥有指向索引节点的指针，共享的其他用户只有路径</li><li>文件主删除后，其他用户再访问会出错</li><li>软链接读共享文件，需要根据路径依次查找目录，多次读盘<ul><li>硬链接的查找速度比软链接快</li></ul></li></ul></li></ul><h2 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h2><h3 id="文件系统结构"><a href="#文件系统结构" class="headerlink" title="文件系统结构"></a>文件系统结构</h3><ul><li><p>需要定义文件系统的用户接口，比如文件及属性、允许的操作、目录结构</p></li><li><p>创建算法和数据结构，映射逻辑文件系统到物理外存设备</p></li><li><p><strong>I&#x2F;O控制层</strong></p><ul><li>包括设备驱动和中断处理程序<ul><li>设备驱动将命令翻译成硬件的指令</li></ul></li></ul></li><li><p><strong>基本文件系统</strong></p><ul><li>向对应的设备驱动发送通用命令，以读取和写入磁盘的物理块</li><li>管理内存缓冲区</li><li>事关系统性能优化</li></ul></li><li><p><strong>文件组织模块</strong></p><ul><li>组织文件及其逻辑块和物理块。</li><li>可以将文件逻辑块地址转换为物理块地址</li><li>包括空闲空间管理器，跟踪未分配的块</li></ul></li><li><p><strong>逻辑文件系统</strong></p><ul><li>管理文件系统中的元数据信息<ul><li>元数据包括文件系统的所有结构，而不包括实际数据（或文件内容）</li></ul></li><li>管理目录结构</li><li>通过FCB维护文件结构</li><li>文件保护</li></ul></li></ul><h3 id="文件系统布局"><a href="#文件系统布局" class="headerlink" title="文件系统布局"></a>文件系统布局</h3><ul><li><p><strong>文件系统在磁盘中结构</strong></p><ul><li>多数磁盘划分为一个或多个分区，每个分区中有一个独立的文件系统</li><li>可能包括：启动存储在那里的OS的方式 总块数 空闲块数量和位置 目录结构 各具体文件<br><img src="https://shingeki-pic.oss-cn-nanjing.aliyuncs.com/img/20250402111625192.png"></li><li><strong>主引导记录（Master Boot Record, MBR）</strong><ul><li>位于磁盘0号扇区，用于引导计算机</li><li>MBR后面是分区表，给出每个分区的起始结束地址</li><li>表中第一个分区被标记为<strong>活动分区</strong></li><li>计算机启动时，<strong>BIOS</strong>读入并执行MBR。MBR首先确定活动分区，读入它的第一块（<strong>引导块</strong>）</li></ul></li><li><strong>引导块（boot block）</strong><ul><li>MBR执行引导块中程序后，该程序启动该分区中的OS</li><li>每个分区统一从一个引导块开始，即使不含OS，也不排除后续会安装一个</li></ul></li><li><strong>超级块（super block）</strong><ul><li>包含<strong>文件系统所有关键信息</strong><ul><li>包括分区的块的数量 块的大小 空闲块数量和指针 空闲FCB数量和FCB指针</li></ul></li><li>在计算机启动时，或者文件系统首次使用时，超级块会被读入内存</li></ul></li><li><strong>文件系统中空闲块的信息</strong><ul><li>用<strong>位视图</strong>或者<strong>指针链接</strong>形式给出</li></ul></li></ul></li><li><p><strong>文件系统在内存中结构</strong></p><ul><li>内存中信息用于管理文件系统 并通过缓存提高性能</li><li>包括<ul><li>安装表（mount table），包含每个已安装文件系统分区的有关信息</li><li>目录结构的缓存，包含最近访问目录的信息</li><li>整个系统的打开文件表</li><li>每个进程的打开文件表</li></ul></li></ul></li></ul><h3 id="外存空闲空间管理"><a href="#外存空闲空间管理" class="headerlink" title="外存空闲空间管理"></a>外存空闲空间管理</h3><ul><li><p>包含文件系统的分区通常称为<strong>卷（volume）</strong></p></li><li><p>卷可以是磁盘的一部分，也可以是整个磁盘，还可以是多个磁盘组成RAID集</p></li><li><p>一个卷中，存放文件数据的空间（文件区）和FCB的空间（目录区）是分开的</p></li></ul><p><img src="https://shingeki-pic.oss-cn-nanjing.aliyuncs.com/img/20250402111633064.png"></p><ul><li><p>文件存储设备分成许多大小相同的物理块，以块为单位交换信息</p></li><li><p><strong>磁盘空闲空间管理方法（10 14 15 19 23 24）</strong></p><ul><li><strong>空闲表法</strong><ul><li>连续分配方式使用</li><li>为外存上所有空闲区建立一张空闲表<ul><li>每个空闲区对应一个空闲表项<br><img src="https://shingeki-pic.oss-cn-nanjing.aliyuncs.com/img/20250402111640882.png"></li></ul></li><li>盘块的分配：<ul><li>与内存动态分配类似，采用首次适应算法、最佳适应算法等</li></ul></li><li>盘块的回收<ul><li>也类似内存回收，决定是否合并</li></ul></li><li><strong>优点</strong>：较高的分配速度，减少访问磁盘的I&#x2F;O频率</li></ul></li><li><strong>空闲链表法</strong><ul><li>所有空闲盘区拉成一条空闲链，分为两种</li><li>空闲盘块链<ul><li>磁盘上所有空闲空间以盘块为单位拉成一条链</li><li>每个盘块都有指向下个盘块的指针</li><li>从链首分配，从链尾插入</li><li>优点：分配回收简单</li><li>缺点：分配时可能重复操作多次，效率低；以盘块为单位，链可能很长</li></ul></li><li>空闲盘区链<ul><li>磁盘上所有空闲盘区拉成一条链<ul><li>每个盘区包含若干相邻盘块</li></ul></li><li>优缺点和上面相反</li></ul></li></ul></li><li><strong>位视图法</strong><ul><li>利用二进制的一位表示磁盘中一个盘块的使用情况</li><li>0表示空闲 1表示已分配<br><img src="https://shingeki-pic.oss-cn-nanjing.aliyuncs.com/img/20250402111647675.png"></li><li><strong>盘块的分配</strong><ul><li>顺序扫描位视图，找到一个或一组<strong>0</strong></li><li>找到的一个或一组二进制位转换成对应的盘块号<ul><li><strong>0</strong>位于第$i$行第$j$列</li><li>盘块号$bno&#x3D;n(i-1)+j$</li></ul></li><li>修改位视图，令 $map[i,j]&#x3D;1$</li></ul></li><li><strong>盘块的回收</strong><ul><li>将回收盘块号转换为行号和列号<ul><li>$$i&#x3D;(b-1)&#x2F;n + 1$$</li><li>$$j&#x3D;(b-1)%n + 1$$</li></ul></li><li>修改位视图，令 $map[i,j]&#x3D;0$</li></ul></li><li>上面的几个式子的 $i, j$ 从1开始编号，实际题目中可能从0开始</li><li><strong>优点</strong><ul><li>容易找到一个或一组相连空闲盘块</li><li>占用空间少，可以保存在内存，节省磁盘启动的开销</li></ul></li><li><strong>缺点</strong><ul><li>随着磁盘容量增加而增大，只常用于小型计算机</li></ul></li></ul></li><li><strong>成组链接法</strong><ul><li>UNIX采用</li><li>空闲盘块分为若干组，每组第一个盘块记录<strong>下一组</strong>空闲盘块总数和空闲盘块号</li><li>这样，<strong>各组第一个盘块</strong>就可以链接成一条链</li><li><strong>第一组</strong>的空闲盘块总数和空闲盘块号保存在内存专用栈中，称为<strong>空闲盘块号栈</strong></li><li>最后一组的第一个块中存放的是0</li><li><strong>盘块分配这里似乎有问题？</strong></li></ul></li></ul></li></ul><h3 id="虚拟文件系统（VFS）"><a href="#虚拟文件系统（VFS）" class="headerlink" title="虚拟文件系统（VFS）"></a>虚拟文件系统（VFS）</h3><ul><li><p>屏蔽了不同文件系统的差异和操作细节，向上为用户提供了文件操作的<strong>统一调用接口</strong></p></li><li><p>用户程序通过VFS提供的统一调用函数（如open）操作文件，无需考虑具体文件系统和存储介质</p></li></ul><p><img src="https://shingeki-pic.oss-cn-nanjing.aliyuncs.com/img/20250402111655565.png"></p><ul><li><p>面向对象 抽象出通用文件模型，定义通用接口</p></li><li><p><strong>四种对象类型</strong></p><ul><li>每个对象都包含数据和函数指针<ul><li>函数指针指向文件系统的实现函数</li></ul></li><li><strong>超级块对象</strong><ul><li>表示一个已安装（或称挂载）的特定文件系统</li><li>超级块对象对应于磁盘上特定扇区的文件系统超级块<ul><li>用于存储已安装文件系统的元信息</li></ul></li><li>操作方法包含一系列可在超级块对象上调用的操作函数<ul><li>如分配inode 销毁inode 读inode 写inode</li></ul></li></ul></li><li><strong>索引节点对象</strong><ul><li>表示一个特定文件</li><li>文件被访问时才在内存中创建索引节点对象<ul><li>每个索引节点对象都会复制磁盘索引节点包含的一些数据</li></ul></li></ul></li><li><strong>目录项对象</strong><ul><li>表示一个特定目录项</li><li>目录项对象是一个路径的组成部分<ul><li>包含指向关联索引节点的指针，还包含指向父目录和指向子目录的指针</li></ul></li><li>VFS遍历路径的过程中，将它们逐个解析成目录项对象</li></ul></li><li><strong>文件对象</strong><ul><li>表示一个<strong>与进程相关的</strong>已打开文件</li><li>文件对象仅是进程视角上代表已打开的文件，它反过来指向其索引节点</li><li>文件对象包含<ul><li>与该文件相关联的目录项对象</li><li>该文件的文件系统 文件指针</li><li>一系列操作函数</li></ul></li><li>进程发起一个面向文件的系统调用时，内核调用VFS中的一个函数，该函数调用目标文件系统中的相应函数，将系统文件请求转换到面向设备的指令<br><img src="https://shingeki-pic.oss-cn-nanjing.aliyuncs.com/img/20250402111704090.png"></li></ul></li></ul></li></ul><h3 id="文件系统挂载"><a href="#文件系统挂载" class="headerlink" title="文件系统挂载"></a>文件系统挂载</h3><ul><li><p>文件系统在进程使用之前必须先安装，也称<strong>挂载</strong></p></li><li><p>将设备中文件系统挂载到某个目标后，就可通过这个目录访问设备上的文件</p><ul><li>设备指逻辑上的设备，比如磁盘的不同分区就可以视为不同设备</li></ul></li><li><p>Windows系统维护一个扩展的两级目录结构，用驱动器字母表示设备和卷</p><ul><li>卷具有常规树结构的目录，与驱动器号关联，还含有指向已安装文件系统的指针</li><li>路径形式：driver-letter:\path\to\file</li></ul></li><li><p>UNIX使用系统的根文件系统，它在系统启动时直接安装</p><ul><li>其他文件系统都需要挂载到根文件系统中的某个目录</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
            <tag> OS </tag>
            
            <tag> 考研 </tag>
            
            <tag> 文件管理 </tag>
            
            <tag> 文件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>王道OS看书笔记——内存管理</title>
      <link href="/2025/03/30/OS-learning-2/"/>
      <url>/2025/03/30/OS-learning-2/</url>
      
        <content type="html"><![CDATA[<p>本文为我考研期间看王道书时写的飞书笔记，根据各知识点的逻辑关系进行整理，添加了一点自己的理解，内容不如王道书全。</p><h2 id="内存管理概念"><a href="#内存管理概念" class="headerlink" title="内存管理概念"></a>内存管理概念</h2><h3 id="内存管理的基本原理和要求"><a href="#内存管理的基本原理和要求" class="headerlink" title="内存管理的基本原理和要求"></a>内存管理<strong>的基本原理和要求</strong></h3><ul><li><p><strong>程序的链接和装入（11）</strong></p><ul><li>创建进程首先要将程序和数据装入内存，将用户源程序变成可在内存中执行的程序。</li><li><strong>编译</strong><ul><li>编译程序将用户源代码编译成若干目标模块</li></ul></li><li><strong>链接</strong><ul><li>链接程序将编译后的目标模块以及它们所需的库函数链接在一起，形成完整装入模块</li><li><strong>三种链接方式（链接时间不同）：</strong><ul><li><strong>静态链接</strong><ul><li>运行之前将目标模块和库函数链接，以后不再拆开。</li><li>需要修改相对地址、变换外部调用符号为相对地址<ul><li>GPT: 外部调用符号（external symbol）是指在一个目标文件（object file）中声明或引用的，但定义在另一个目标文件中的符号。</li></ul></li></ul></li><li><strong>装入时动态链接</strong><ul><li>装入内存时，边装入边链接。</li><li><strong>优点：</strong> 便于修改和更新，便于实现对目标模块的共享</li></ul></li><li><strong>运行时动态链接</strong><ul><li>程序执行中需要某目标模块时才链接。</li><li><strong>优点：</strong> 加快程序装入过程，节省内存。</li></ul></li></ul></li></ul></li><li><strong>装入</strong><ul><li>装入程序将装入模块放入内存运行</li><li><strong>三种方式：</strong><ul><li><strong>绝对装入</strong><ul><li>只适用于<strong>单道程序环境</strong></li><li>编译时若知道程序在内存中的位置，则编译产生绝对地址的目标代码</li><li>装入程序按照装入模块的地址将程序和数据装入内存</li></ul></li><li><strong>可重定位装入（静态重定位）</strong><ul><li>编译、链接后的装入模块的起始地址通常从 0 开始</li><li>程序中指令和数据地址都相对于起始地址，此时应该用可重定位装入</li><li><strong>重定位</strong>：装入时对目标程序中的相对地址的修改过程</li><li>作业装入内存时必须分配要求的全部内存，且运行期间不能在内存中移动或继续申请空间</li></ul></li><li><strong>动态运行时装入（动态重定位）</strong><ul><li>地址转换推迟到程序执行时</li><li>装入内存后的所有地址都是相对地址</li><li>需要重定位寄存器存放装入模块的起始位置</li><li><strong>优点：</strong><ul><li>将程序分配到不连续的存储区</li><li>只需要装入部分代码就可以投入运行</li><li>便于程序段共享</li></ul></li></ul></li></ul></li></ul></li></ul></li><li><p><strong>逻辑地址和物理地址（23）</strong></p><ul><li><strong>逻辑地址</strong><ul><li>编译后，每个目标模块都从 0 号单元开始编址，称为目标模块的<strong>相对地址（或逻辑地址）</strong></li><li>各模块链接时，链接程序顺序依次按隔各个模块的相对地址构成<strong>统一的</strong>从 0 号单元开始编制的逻辑地址空间（或虚拟地址空间），对于 32 位系统，逻辑地址空间的范围为 0 ~ 2^32 - 1。<ul><li>GPT: 链接程序会将所有这些模块的相对地址整合成一个从 0 号单元开始的统一逻辑地址空间。在这个过程中，链接器会把各个模块的相对地址重新映射为全局的逻辑地址，确保它们在一个连续的逻辑地址空间中排列。</li></ul></li><li>进程运行时，<strong>看到的和使用的都是逻辑地址</strong>。</li><li><strong>用户程序和程序员只需知道逻辑地址</strong>，内存管理的具体机制是透明的（注意透明含义）。</li><li><strong>不同进程可以有相同的逻辑地址</strong>，因为这些地址实际映射到主存的不同位置。</li></ul></li><li><strong>物理地址</strong><ul><li>物理地址空间是内存中物理单元的集合。</li></ul></li><li>OS 通过内存管理部件（MMU）将进程使用的逻辑地址转化为物理地址。</li><li>逻辑地址通过页表映射到物理内存，页表由 OS 维护并被处理器引用。</li></ul></li><li><p><strong>进程的内存映像</strong></p><ul><li>分为<strong>代码段 数据段 PCB 堆 栈</strong>等等</li><li>代码段和数据段在程序调入内存时就指定大小</li><li>调用 malloc 或 free 这样的函数时，堆会变化</li><li>调用函数或从函数返回，栈会变化</li></ul></li><li><p><strong>内存保护（09）</strong></p><ul><li>内存保护是确保每个进程有单独的内存空间，OS 和用户进程、用户进程之间互不干扰。</li><li><strong>两种方法：</strong><ul><li>在 CPU 设置一堆上下限寄存器，存放用户进程在主存中的上限和下限地址，CPU 访问地址时与寄存器对比确认是否越界。</li><li>采用重定位寄存器（基地址寄存器）和界地址寄存器（限长寄存器）进行越界检查。重定位寄存器存放进程起始物理地址，界地址寄存器存放进程最大逻辑地址。<ul><li>这两个寄存器的加载必须使用特权指令。内核可以对它们进行修改，用户程序不可以。<br><img src="https://shingeki-pic.oss-cn-nanjing.aliyuncs.com/img/20250402110819714.jpg"></li></ul></li></ul></li></ul></li><li><p><strong>内存共享</strong></p><ul><li><strong>只读</strong>的区域才可以共享。</li></ul></li><li><p><strong>内存分配和回收</strong></p><ul><li>页式存储管理 分段存储管理</li></ul></li></ul><h3 id="连续分配管理方式"><a href="#连续分配管理方式" class="headerlink" title="连续分配管理方式"></a>连续分配管理方式</h3><ul><li><p><strong>单一连续分配</strong></p><ul><li>内存分为系统区和用户区，系统区仅供 OS 使用，用户区仅有一道用户程序</li><li>简单，无外部碎片</li><li>单用户 单任务</li><li>有内部碎片（分区内部的碎片）</li><li>存储器利用率极低</li></ul></li><li><p><strong>固定分区分配</strong></p><ul><li>用户内存空间划分为若干固定大小的分区，每个分区只装入一道作业。</li><li>有空闲分区时，从外存的后备作业队列选择适当大小的作业装入该分区。</li><li>分区划分大小可以相等，可以不等。</li><li>建立<strong>分区使用表</strong>，便于分配和回收。<br><img src="https://shingeki-pic.oss-cn-nanjing.aliyuncs.com/img/20250402110923848.jpg"></li></ul></li><li><p><strong>动态分区分配（可变分区分配）（10 17 19 24）</strong></p><ul><li><p>进程装入内存时，根据实际需要，动态地分配内存，使大小<strong>正好符合进程需要</strong>。</p></li><li><p>随着时间推移，会产生小内存块 <strong>（外部碎片，存在于所有分区的外部）</strong> ，内存利用率下降。</p></li><li><p>外部碎片可以通过<strong>紧凑技术</strong>克服，即 OS 不时地对进程进行移动和整理，但需要动态重定位寄存器的支持，且比较费时。</p></li><li><p><strong>内存分配和回收方法</strong></p><ul><li><p>设置一张<strong>空闲分区链（表）</strong>，可以按起始地址排序</p></li><li><p>分配时，检索空闲分区链，找到所需分区：</p><ul><li>若分区大小大于请求大小，则从该分区中<strong>按请求大小分割</strong>一块空间给装入进程（若剩余部分过小，则不需要分割），余下部分仍在空闲分区链中。</li></ul></li><li><p>回收时，根据回收分区的起始地址，从空闲分区链中找到相应插入点，如果回收区和其他空闲分区<strong>相邻，则合并</strong>，最多三块合并。如果没有空闲分区相邻，则不合并。</p></li><li><p><strong>分配算法</strong></p><ul><li><p>作业装入主存时，需要以分配算法从空闲分区链中选出一个分区。</p></li><li><p><strong>顺序分配算法</strong></p><ul><li>依次搜索空闲分区链上的空闲分区，寻找大小合适的分区，有 4 种</li></ul><ol><li><strong>首次适应（First Fit）算法</strong><ul><li>空闲分区按<strong>地址递增次序</strong>排列。</li><li>顺序查找第一个满足大小的分区。</li><li>保留了高地址的大空闲分区，<strong>有利于大作业的装入</strong></li><li>低地址部分出现小碎片，而每次分配查找时都会经过这些分区，<strong>增加开销</strong></li></ul></li><li><strong>邻近适应（Next Fit）算法（循环首次适应算法）</strong><ul><li>其他与首次适应类似，但分配内存时从上次查找结束的位置开始。</li><li>低地址和高地址同等概率被分配</li><li>高地址没有大空闲分区可用</li></ul></li><li><strong>最佳适应（Best Fit）算法</strong><ul><li>空闲分区按<strong>容量递增次序</strong>排列。</li><li>每次分配，顺序查找第一个满足大小的空闲分区，也就是最小的适合的空闲分区</li><li>分配后需要重新排序</li><li>能够更多留下大空闲分区</li><li>每次分配会留下很多小的难以利用的内存块，<strong>产生最多的外部碎片</strong>，性能差。</li></ul></li><li><strong>最坏适应（Worst Fit）算法</strong><ul><li>空闲分区按<strong>容量递减次序</strong>排列。</li><li>每次分配，顺序查找第一个满足大小的空闲分区，也就是最大的空闲分区，分割一部分给作业</li><li>分配后需要重新排序</li><li>划分大空间会导致没有大空间可用，性能差</li></ul></li></ol><ul><li><strong>首次适应算法开销小，性能最好，且分配后不需要重新排序。</strong></li></ul></li><li><p><strong>索引搜索算法</strong></p><ul><li>根据大小对空闲分区分类，每类空闲分区单独设链表</li><li>设置索引表管理这些链表</li><li>分配时，在索引表中查找对应所需空间大小的表项，得到链表头指针，从而获得空闲分区</li><li>大中系统常用</li></ul><ol><li><strong>快速适应算法</strong><ul><li>空闲分区的分类根据<strong>进程常用的空间大小</strong>。</li><li>分配时，首先根据进程长度，在索引表中找到能容纳的最小空闲分区链</li><li>然后从链表中<strong>取出第一块</strong>进行分配</li><li><strong>查找效率高，不产生内部碎片</strong></li><li><strong>回收分区</strong>时，需要有效地<strong>合并分区，算法复杂，开销大</strong>。</li></ul></li><li><strong>伙伴系统（24）</strong><ul><li>规定所有分区的大小为 2 的 k 次幂，分配时寻找能容纳的最小空闲分区链</li><li>如果找到（ 2^i ），则分配；如果找不到，到大小为两倍的空闲分区链中查找</li><li>如果存在，则将其等分，称为<strong>一对伙伴</strong>，一个用于分配，另一个加入大小 2^i 的链表中</li><li>若仍不存在，则继续查找，直到找到为止</li><li>回收时，可能需要对伙伴分区进行合并</li></ul></li><li><strong>哈希算法</strong><ul><li>根据空闲分区链的分布规律，建立哈希函数，构建以空闲分区大小为关键字的哈希表</li><li>每个表项记录一个对应空闲分区链的头指针</li><li>分配时，根据所需大小，通过哈希函数计算得到哈希表中位置，然后得到链表</li></ul></li></ol></li></ul></li></ul></li></ul></li><li><p><strong>对于单一分区分配、固定分区分配和动态分区分配，用户程序在主存中都是连续存放的。</strong></p></li></ul><h3 id="基本分页存储管理"><a href="#基本分页存储管理" class="headerlink" title="基本分页存储管理"></a>基本分页存储管理</h3><p>内存空间分为若干固定大小的分区，称为<strong>页框、页帧或物理块</strong></p><p>进程的逻辑地址空间也分为与块<strong>大小相等</strong>的若干区域，称为<strong>页或页面</strong></p><p>分页管理不产生外部碎片。</p><p>进程只有为最后一个不完整的块申请主存块空间时，才会产生内部碎片。</p><p>每个进程平均产生半个块大小的内部碎片</p><ul><li><p><strong>分页存储的基本概念</strong></p><ul><li>进程的逻辑地址空间每个页面有一个编号，称为<strong>页号</strong>，从 0 开始</li><li>内存空间的每个页框也有编号，称为<strong>页框号（物理块号）</strong>，也从 0 开始</li><li>页面大小为 2 的整数次幂，页面太小会使进程页面数过多，页表过长，占用大量内存，也会增加硬件地址转换的开销，降低页面换入&#x2F;换出的效率</li><li>页面过大会使页内碎片增多，降低内存利用率</li><li><strong>分页系统的逻辑地址结构（09 10 13 15 17）</strong><br><img src="https://shingeki-pic.oss-cn-nanjing.aliyuncs.com/img/20250402110935702.jpg"></li><li>系统为每个进程建立一张<strong>页面映射表，简称页表</strong><ul><li>进程每个页面对应一个<strong>页表项</strong></li><li>每个<strong>页表项</strong>由<strong>页号</strong>和<strong>块号</strong>组成，记录了页面在内存中的物理块号</li><li>页表项连续存放，因此<strong>页号可以隐含</strong>，不占空间</li><li>进程执行时，通过查找页表就能找到每页在内存中的物理块号<br><img src="https://shingeki-pic.oss-cn-nanjing.aliyuncs.com/img/20250402110949518.jpg"></li></ul></li></ul></li><li><p><strong>基本地址变换机构（13 21 24）</strong></p><ul><li>地址变换机构的任务是将逻辑地址转换为物理地址。是借助页表实现的。<br><img src="https://shingeki-pic.oss-cn-nanjing.aliyuncs.com/img/20250402111001349.jpg"></li><li>为提高地址变换的速度，在系统中设置一个页表寄存器，存放页表<strong>在内存的起始地址</strong>和<strong>页表长度</strong>。</li><li>进程未执行时，页表起始地址和长度存放在本进程的 PCB 中</li><li>进程被调度执行时，将这两样装入页表寄存器</li><li><strong>页式系统的地址变换过程</strong><ol><li>设页面大小为$L$ 逻辑地址$A$ 物理地址$E$ 页表起始地址 $F$ 页表长度 $M$</li><li>页号 $P&#x3D;A&#x2F;L$ , 页内偏移量 $W&#x3D;A%L$</li><li>判断是否页号是否越界。若页号 $P$ &gt;&#x3D; 页表长度 $M$，则产生越界中断</li><li>在页表中查询页号对应页表项，确定页面存放的物理块号。<ul><li>$P$ 对应的<strong>页表项地址</strong> &#x3D; $F$ + $P$ * 页表项长度</li><li>取出物理块号 $b$</li></ul></li><li>计算物理地址 $E&#x3D;b×L+W$</li></ol></li><li>存在的主要问题<ul><li>每次访存都需要进行逻辑地址到物理地址的转换，地址转换必须足够快</li><li>每个进程引入页表，用于存储映射机制，页表不能太大，否则内存利用率降低</li></ul></li></ul></li><li><p><strong>具有快表的地址变换机构（09）</strong></p><ul><li>上述地址变换过程，页表在内存中，需要两次访存</li><li>增设一个具有并行查找能力的高速缓冲存储器<strong>快表（TLB）（相联存储器），在 CPU 中</strong><ul><li>快表中存放当前访问的若干<strong>页表项</strong><br><img src="https://shingeki-pic.oss-cn-nanjing.aliyuncs.com/img/20250402111015020.jpg"></li></ul></li><li><strong>地址变换过程</strong><ul><li>CPU 给出逻辑地址，硬件进行地址转换，将页号与快表中所有页号进行比较</li><li>如果有匹配的页号，直接读页框号，得到物理地址</li><li>如果没有，则访问主存中页表，并将页表项存入快表。若快表已满，则按一定算法淘汰一个旧页表项。</li></ul></li></ul></li><li><p><strong>两级页表（10 13 14 15 17 18 19 21）</strong></p><ul><li>页表会占用连续的很大的空间，故引入多级页表</li><li>页表离散分配，为这些页表再建立一张页表，称为<strong>外层页表（页目录）</strong></li><li>以 32 位系统 4KB 页面大小为例<br><img src="https://shingeki-pic.oss-cn-nanjing.aliyuncs.com/img/20250402111033825.jpg"></li><li><strong>两级页表的结构</strong><br><img src="https://shingeki-pic.oss-cn-nanjing.aliyuncs.com/img/20250402111044428.jpg"></li><li><strong>地址变换过程</strong><ul><li>增设一个<strong>外层页表寄存器（页目录基址寄存器），</strong> 存放页目录起始地址</li><li>将逻辑地址中页目录号作为页目录索引，找到页表起始地址</li><li>用二级页号作为页表索引，找到页表项</li><li>将页表项中物理块号和页内偏移拼接得到物理地址</li><li>共三次访存</li></ul></li><li>多级页表解决了逻辑地址空间过大时，页表长度大大增加的问题</li><li>一次访盘需要多次访问内存甚至磁盘，大大增加一次访存的时间</li><li>注意第二级页表的大小最大为 1 页（理解：第一级页表也是页表，所指向的区域一定是一页大小）</li></ul></li></ul><h3 id="基本分段存储管理"><a href="#基本分段存储管理" class="headerlink" title="基本分段存储管理"></a>基本分段存储管理</h3><p><strong>分页</strong>通过<strong>硬件机制</strong>实现，对用户透明</p><p><strong>分段</strong>管理考虑了<strong>用户和程序员</strong>，满足编程、信息保护和共享等需要</p><ul><li><p><strong>分段（09）</strong></p><ul><li>分段系统将用户进程的逻辑地址空间分为大小不等的段</li><li>比如用户程序由 主程序段 两个子程序段 栈段 数据段 组成<ul><li>将进程划分为 5 段，<strong>每段从 0 开始编址</strong></li><li><strong>段内地址连续</strong>，段间不要求连续<br><img src="https://shingeki-pic.oss-cn-nanjing.aliyuncs.com/img/20250402111056920.jpg"></li></ul></li><li>段号和段内偏移量由用户显式提供（section .data ？）。高级语言中编译器完成这部分工作。</li></ul></li><li><p><strong>段表（16）</strong></p><ul><li><p><strong>每个进程</strong>都有一张逻辑空间和内存空间映射的<strong>段表</strong>，进程中每个段对应一个段表项</p><table><tr>    <td>段号<br/></td>    <td>段长<br/></td>    <td>本段在主存的起始地址<br/></td></tr></table></li><li><p>执行中的进程可以查找段表，找到每段对应的内存区<br><img src="https://shingeki-pic.oss-cn-nanjing.aliyuncs.com/img/20250402111103945.jpg"></p></li><li><p><strong>地址变换机构</strong></p><ul><li>在系统中设置一个段表寄存器，存放段表起始地址 $F$ 和段表长度 $M$</li><li>从逻辑地址 $A$到物理地址 $E$的转换过程：<ul><li>从逻辑地址中取出前几位段号 $S$，后几位段内偏移量 $W$</li><li>判断段号是否越界。若 $S≥M$，则产生越界中断</li><li>在段表中查询段号对应段表项， $S$对应的<strong>段表项地址</strong> &#x3D; $F$ + $S$× 段表项长度</li><li>取出段表项中的段长 $C$，若 $W≥C$，则产生越界中断</li><li>取出段表项中该段起始地址 $b$，物理地址 $E&#x3D;b+W$</li></ul></li></ul></li></ul></li><li><p><strong>分页和分段的对比</strong></p><ul><li>页是信息的物理单位，目的是提高内存利用率；段是信息的逻辑单位，目的是更好地满足用户需求</li><li>分页对用户不可见，分段对用户可见</li><li>页的大小固定，段的大小不固定</li><li><strong>分页管理的地址空间是一维</strong>的，而<strong>分段管理</strong>因为每段长度不固定，无法根据一个数得到物理地址，需要显式给出段号和段内偏移，因此是<strong>二维</strong>的。</li></ul></li><li><p><strong>段的共享和保护（19 23）</strong></p><ul><li>分页系统中，可以实现共享，但不方便<ul><li>若被共享的代码占 N 个页框，则每个进程的页表中都要建立 N 个页表项，指向被共享的页框</li></ul></li><li>分段系统中，在<strong>每个进程的段表</strong>中设置一个段表项，指向被共享的物理段</li><li>不能被任何进程修改的代码称为<strong>可重入代码</strong>或者<strong>纯代码</strong><ul><li>这种代码允许多个进程同时访问</li><li>为了防止程序执行时修改共享代码，每个进程中配备局部数据区，将可能改变的部分复制到数据区修改</li></ul></li><li><strong>分段管理的保护</strong><ul><li>存取控制保护（GPT: 权限控制）</li><li>地址越界保护<ul><li>段表寄存器中的段表长度和逻辑地址中段号比较，段号更大则产生越界中断</li><li>段表项中段长和逻辑地址中的段内偏移比较，段内偏移更大则产生越界中断</li></ul></li></ul></li></ul></li></ul><h3 id="段页式存储管理"><a href="#段页式存储管理" class="headerlink" title="段页式存储管理"></a>段页式存储管理</h3><p>进程的地址空间分为若干逻辑段，每段有自己段号，将各段分为若干大小固定的页。</p><p>对内存空间的管理和分页管理一样，分为若干和页面大小一致的存储块，内存分配以存储块为单位。</p><p><img src="https://shingeki-pic.oss-cn-nanjing.aliyuncs.com/img/20250402111112358.jpg"></p><p>段页式系统中的逻辑地址分为<strong>段号 页号和页内偏移量</strong></p><p>系统为<strong>每个进程建立一张段表</strong>，每个段对应一个段表项，每个段表项包括<strong>段号 页表长度 页表起始地址</strong></p><p><strong>每个段有一张页表</strong>，页表项包括页号和块号</p><p>每个进程段表只有一个，页表可能有多个</p><p>系统中有一个<strong>段表寄存器</strong>，指出进程的段表起始地址和段表长度</p><p>段表寄存器和页表寄存器的作用都是在页表或段表中寻址以及判断是否越界。</p><p>地址变换时，首先用段表查到页表起始地址，然后通过页表找到物理块号，形成物理地址。</p><p>该过程需要三次访问主存</p><p>此处也可以使用快表</p><p><img src="https://shingeki-pic.oss-cn-nanjing.aliyuncs.com/img/20250402111125550.jpg"></p><h2 id="虚拟内存管理"><a href="#虚拟内存管理" class="headerlink" title="虚拟内存管理"></a>虚拟内存管理</h2><h3 id="虚拟内存的基本概念"><a href="#虚拟内存的基本概念" class="headerlink" title="虚拟内存的基本概念"></a>虚拟内存的基本概念</h3><ul><li><p><strong>传统存储管理方式的特征</strong></p><ul><li><strong>一次性</strong>。作业必须一次性装入内存才能运行。<ul><li>当作业很大不能全部装入时，无法运行</li><li>大量作业要求运行时，内存不足以容纳所有作业，只能少数先运行，导致并发下降</li></ul></li><li><strong>驻留性。</strong> 作业装入内存后，一直驻留在内存中，任何部分都不会被换出，直到作业运行结束。<ul><li>运行中的进程会因为等待 I&#x2F;O 而被阻塞，可能处于长期等待状态</li></ul></li></ul></li><li><p><strong>局部性原理（12）</strong></p><ul><li><strong>时间局部性</strong><ul><li>程序的某条指令一旦执行，不久后可能再次执行；某数据被访问后，不久后可能再次被访问。</li><li>原因是程序中存在大量循环</li></ul></li><li><strong>空间局部性</strong><ul><li>一旦程序访问了某个存储单元，不久后其附近的存储单元也会被访问</li><li>原因是指令是顺序存放、顺序执行的，数据也一般是向量、数组、表等形式存储的</li></ul></li></ul></li><li><p><strong>虚拟存储器的定义和特征（12）</strong></p><ul><li>基于局部性原理，程序装入时，只需将当前运行所需少数页面或段装入内存，其余暂留外存，便可执行。</li><li><strong>请求调页（请求调段）</strong>：访问的信息不在内存时，OS 将所需信息调入内存，然后继续执行。</li><li><strong>页面置换（段置换）</strong>：内存不够时，OS 将内存中暂时用不到的信息换出到外存</li><li>通过这些操作，系统好像提供了一个比实际物理内存大得多的存储器，称为<strong>虚拟存储器</strong></li></ul></li><li><p><strong>虚拟内存技术的实现</strong></p><ul><li>三种方式：<ul><li>请求分页存储管理</li><li>请求分段存储管理</li><li>请求段页式存储管理</li></ul></li><li>硬件支持：<ul><li>一定容量内存外存</li><li>页表（或段表）机制</li><li>中断机构，当用户访问部分未进入内存时，产生中断</li><li>地址变换机构，从逻辑地址到物理地址</li></ul></li></ul></li></ul><h3 id="请求分页管理方式"><a href="#请求分页管理方式" class="headerlink" title="请求分页管理方式"></a>请求分页管理方式</h3><ul><li><p><strong>页表机制</strong></p><ul><li>请求页表项相比之前的页表项，增加了四个字段。</li><li><strong>状态位</strong> $P$，标记该页是否已经调入内存，供程序访问时参考</li><li><strong>访问字段</strong> $A$ ，记录本页在一段时间内被访问的次数，或者记录本页最近有多久未被访问</li><li><strong>修改位</strong> $M$，标记该页在调入内存后是否被修改过，以决定换出时是否写回外存</li><li><strong>外存地址</strong>，记录该页在外存的存放地址，通常是物理块号，供调入该页时参考</li></ul></li><li><p><strong>缺页中断机构（11 13 14 20 22 23）</strong></p><ul><li>访问的页面不在内存时，产生<strong>缺页中断</strong>，请求 OS 的缺页中断处理程序处理。</li><li>缺页的进程阻塞，调页完成后再唤醒。</li><li>如果内存中有空闲页框，则为进程分配一个页框，将所缺页面从外存装入页框，修改页表相应表项</li><li>如果没有，则由页面置换算法选一个页面淘汰，若该页在内存期间被修改过，还要写回外存</li><li>缺页中断与一般中断的区别：<ul><li>指令执行期间而非一条指令执行完之后产生和处理中断，属于内部异常</li><li>一条指令执行期间可能产生多次缺页中断</li></ul></li></ul></li><li><p><strong>地址变换机构（09 10 14）</strong></p><ul><li>在基本分页系统地址变换机构的基础上，为了实现虚拟内存，增加了产生和处理缺页中断、从内存中换出一页的功能</li><li><strong>过程：</strong><ul><li>先检索快表<ul><li>若命中，从相应表项中取出物理块号，修改页表中访问位。对于写指令，还要将修改位改为 1。</li><li>若未命中，到页表中查找。<ul><li>若找到，则从相应表项中取出物理块号，并将页表项写入快表。<ul><li>若快表已满，采用某种算法替换。</li></ul></li><li>若未找到，则进行缺页中断处理，请求系统将该页从外存换入内存，OS 更新页表和快表，得到物理块号</li></ul></li></ul></li><li>利用得到的物理块号和页内地址拼接得到物理地址<br><img src="https://shingeki-pic.oss-cn-nanjing.aliyuncs.com/img/20250402111135806.png"></li></ul></li></ul></li></ul><h3 id="页框分配"><a href="#页框分配" class="headerlink" title="页框分配"></a>页框分配</h3><ul><li><p><strong>驻留集大小</strong></p><ul><li>不需要将进程的所有页都读入主存，需要 OS 决定分配几个页框</li><li>分配的页框的集合就是这个进程的<strong>驻留集</strong></li><li>驻留集越小，驻留在内存中进程越多，可以提高并发度，但缺页率提高，CPU 耗费大量时间处理缺页</li><li>驻留集过大，对于缺页率改善不多，浪费内存，大幅降低并发度</li></ul></li><li><p><strong>内存分配策略（15）</strong></p><ul><li>请求分页系统中 有固定和可变分配策略</li><li>置换时有全局和局部置换</li><li><strong>固定分配局部置换</strong><ul><li>固定分配：分配固定数目物理块，进程运行期间不变</li><li>局部置换是指如果发生缺页，只能从分配给该进程在内存中的页面选一页换出，再调入一页，保证分配的内存空间不变</li><li>难以确定分配的数目，过少会频繁缺页，过多会降低 CPU 等利用率</li></ul></li><li><strong>可变分配全局置换</strong><ul><li>先分配一定数目物理块，可增加&#x2F;减少</li><li>全局置换：若发生缺页，则从<strong>空闲物理块队列</strong>中取出一块分配给该进程，并将所缺页调入</li><li>盲目给进程增加物理块，会导致并发能力下降</li></ul></li><li><strong>可变分配局部置换</strong><ul><li>分配一定数目物理块，缺页时只从<strong>该进程在内存中的页面</strong>换出，不影响其他进程</li><li>如果频繁缺页，系统再分配若干物理块，直到缺页率适当</li><li>若缺页率特别低，则减少分配</li></ul></li></ul></li><li><p><strong>物理块调入算法</strong></p><ul><li>固定分配策略的空闲物理块分配算法<ul><li>平均分配</li><li>按进程大小比例</li><li>按进程优先级</li></ul></li></ul></li><li><p><strong>调入页面时机</strong></p><ul><li>预调页策略（运行前）<ul><li>预测不久后可能被访问的页面，预先调入</li><li>预测成功率不高</li><li>主要用于进程首次调入</li></ul></li><li>请求调页策略（运行后）<ul><li>进程需要的页面不在内存，提出请求，系统调入。</li></ul></li></ul></li><li><p><strong>从何处调入页面</strong></p><ul><li>请求分页系统的外存分为<ul><li>用于存放文件的文件区<ul><li>离散分配方式</li></ul></li><li>存放对换页面的对换区（交换区）<ul><li>连续分配方式，I&#x2F;O 速度更快</li></ul></li></ul></li><li>三种情况：<ul><li>系统有足够对换区空间<ul><li>全部从对换区调页，提高速度。</li><li>进程运行前需要将有关文件从文件区复制到对换区</li></ul></li><li>系统没有足够对换区空间<ul><li>不会被修改的文件从文件区调入</li><li>可能被修改的部分 换出时必须放在对换区，需要时从对换区调入（因为读比写快）</li></ul></li><li>UNIX 方式<ul><li>进程有关文件都在文件区，因此未运行过的页面都应从文件区调入</li><li>曾经运行过但被换出的页面，因为放在对换区，下次调入时应该从对换区调入</li><li>进程请求的共享页面如果被其他进程调入内存，不再需要从对换区调入</li></ul></li></ul></li></ul></li><li><p><strong>如何调入</strong></p><ul><li>进程访问页面不在内存中（存在位&#x3D;0），发出缺页中断，转入缺页中断处理</li><li>查表得到该页物理块<ul><li>内存未满，启动磁盘 I&#x2F;O，将所缺页调入内存，修改页表</li><li>内存已满，先按某种置换算法选出一页准备换出<ul><li>若该页未被修改（修改位&#x3D;0），则不需要写回</li><li>若修改位&#x3D;1，需要写回，然后将所缺页调入内存，修改页表</li></ul></li></ul></li></ul></li></ul><h3 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h3><ul><li><p><strong>最佳（OPT）置换算法</strong></p><ul><li>淘汰以后永不使用或者最长时间内不再被访问的页面</li><li>无法实现</li></ul></li><li><p><strong>先进先出（FIFO）置换算法（10 14）</strong></p><ul><li>淘汰最早进入内存的页面</li><li>没有利用局部性原理 性能较差</li><li>可能导致 <strong>Belady 异常</strong><ul><li>为进程分配的物理块增多，缺页次数不减反增的现象</li><li>GPT: 原因：这种算法的简单性可能导致一些正在频繁使用的页面被替换出内存，导致缺页率增加。</li><li>只有 FIFO 算法会导致 Belady 异常，LRU 和 OPT 算法不会出现</li></ul></li></ul></li><li><p><strong>最近最久未使用（Least Recently Used, LRU）置换算法（09 15 19）</strong></p><ul><li>淘汰最近最久未使用的页面</li><li>为每个页面设置一个访问字段，记录页面自上次访问以来经历的时间<ul><li>淘汰时选择值最大的页面</li></ul></li><li><strong>性能较好</strong>，接近 OPT，但<strong>开销大</strong></li><li>需要寄存器和栈的硬件支持</li><li>LRU 是堆栈类算法，可以证明堆栈类算法不会出现 Belady 异常</li></ul></li><li><p><strong>时钟（CLOCK）算法（10 12 16 18 21）</strong></p><ul><li><strong>简单的 CLOCK 置换算法</strong><ul><li>每个页面设置一个<strong>访问位</strong><ul><li>页面首次被装入或被访问时，访问位修改为 1</li></ul></li><li>算法将内存中的页面链接成一个循环队列，并有一个替换指针与之相关联<ul><li>指针顺序移动 初始指向第一个页</li><li>指针只在选择要替换的页面的时候移动，如果没有发生缺页不会移动</li><li>选择淘汰一页的时候，检查页面的<strong>访问位</strong><ul><li>若为 1，改为 0</li><li>若为 0，淘汰</li></ul></li><li>当某一页被替换时，该指针指向<strong>被替换页面的下一页</strong></li></ul></li><li>也称最近未用（NRU）算法</li></ul></li><li><strong>改进 CLOCK 置换算法</strong><ul><li>将页面换出的时候，若已被修改，需要写回磁盘，替换代价大</li><li>与上一种相比，添加了一个修改位</li><li>访问位 A 修改位 M<ul><li>A &#x3D; 0, M &#x3D; 0 最佳淘汰页</li><li>A &#x3D; 0, M &#x3D; 1 次佳淘汰页</li><li>A &#x3D; 1, M &#x3D; 0 或 1 可能再次被访问</li></ul></li><li><strong>算法执行过程</strong><ul><li>与简单 CLOCK 相似</li><li>从指针当前位置开始，扫描循环队列，寻找 A &#x3D; 0 M &#x3D; 0 的 1 类页面，将第一个 1 类页面作为淘汰页。<ul><li>第一次扫描期间不改变访问位 A</li></ul></li><li>若第一步失败，则进行第二轮扫描，寻找 A &#x3D; 0 M &#x3D; 1 的 2 类页面，将第一个 2 类页面作为淘汰页。<ul><li>第二次扫描将所有扫描过的页面访问位改为 0</li></ul></li><li>若第二步失败，则指针返回开始位置，将所有页面访问位设为 0。</li><li>重复第一步，若有必要则重复第二步，一定能找到淘汰页。</li></ul></li><li>比简单 CLOCK 减少磁盘 I&#x2F;O 次数，但实现算法本身开销可能增加</li></ul></li></ul></li></ul><h3 id="内存映射文件"><a href="#内存映射文件" class="headerlink" title="内存映射文件"></a>内存映射文件</h3><ul><li><p>内存映射文件是 OS 提供的一个<strong>系统调用</strong></p></li><li><p>与虚拟内存相似，在磁盘文件和进程的虚拟地址空间之间建立映射</p></li><li><p>将一个文件映射到其虚拟地址空间的某个区域，之后用访问内存的方式读写文件</p><ul><li>将文件作为内存中一个大字符数组访问，比文件 I&#x2F;O 更便利</li></ul></li><li><p>磁盘文件的读写由 OS 完成，对进程透明</p></li><li><p>退出或者关闭文件映射的时候，改动才写回磁盘</p></li><li><p>很多时候，<strong>共享内存</strong>是通过映射相同文件到通信进程的虚拟地址空间实现的</p></li><li><p>一个进程在共享内存上进行了写操作，另一个进程能立刻读到结果</p></li></ul><p><img src="https://shingeki-pic.oss-cn-nanjing.aliyuncs.com/img/20250402111149363.png"></p><h3 id="虚拟存储器性能影响因素（20-22）"><a href="#虚拟存储器性能影响因素（20-22）" class="headerlink" title="虚拟存储器性能影响因素（20 22）"></a>虚拟存储器性能影响因素（20 22）</h3><ul><li>缺页率是影响虚拟存储器性能的主要因素<ul><li>缺页率又受到页面大小 分配的物理块数 页面置换算法 程序编制方法的影响</li><li>页面较大，缺页率较低；页面较小，减少内存碎片，提高内存利用率</li><li>分配给进程物理块越多，缺页率越低，但超过某个数目时，对缺页率降低不明显</li><li>LRU CLOCK 等置换算法缺页率低</li><li>编写程序的局部化程度越高，缺页率越低<ul><li>若存储按行，访问时就要尽量采用相同方式</li></ul></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
            <tag> OS </tag>
            
            <tag> 考研 </tag>
            
            <tag> 内存管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>王道OS看书笔记——进程与线程</title>
      <link href="/2025/03/30/OS-learning-1/"/>
      <url>/2025/03/30/OS-learning-1/</url>
      
        <content type="html"><![CDATA[<p>本文为我考研期间看王道书时写的飞书笔记，根据各知识点的逻辑关系进行整理，添加了一点自己的理解，内容不如王道书全。</p><h2 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h2><p>进程 最基本的两个特性 <strong>并发性和共享性</strong></p><p>引入进程的目的：更好地使多道程序并发，提高资源利用率和系统吞吐量。</p><p>进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位。（<strong>系统资源</strong>指 CPU 存储器 等服务于某个进程的时间）</p><ul><li>专门的数据结构 **进程控制块 PCB，**是进程实体的一部分，<strong>是进程存在的唯一标志。</strong><ul><li>PCB 常用的组织方式有<strong>链接方式和索引方式</strong>。<ul><li>链接方式将<strong>同一状态的 PCB 链接成一个队列</strong>，不同状态对应不同队列。 也可以将处于阻塞态的进程的 PCB，根据其<strong>阻塞原因</strong>的不同，排成多个阻塞队列。</li><li>索引方式将<strong>同一状态的进程组织在一个索引表</strong>中，索引表的表项指向相应的 PCB。</li></ul></li></ul></li></ul><p>多个进程可以运行同一个程序。</p><h3 id="进程的状态和转换（14-15-18-23）"><a href="#进程的状态和转换（14-15-18-23）" class="headerlink" title="进程的状态和转换（14 15 18 23）"></a>进程的状态和转换（14 15 18 23）</h3><ol><li><strong>运行态</strong>：进程在 CPU 上运行。<strong>单 CPU</strong> 中，每个时刻只有一个进程在运行态。</li><li><strong>就绪态：<strong>进程获得除了 CPU 以外的一切资源，一旦得到 CPU 便可立即运行。处于就绪态的进程通常排一个队列，称为</strong>就绪队列</strong>。</li><li><strong>阻塞态：又称等待态</strong>。进程正在等待某个事件而暂停运行，如<strong>等待某资源可用（不包括 CPU）或等 I&#x2F;O 完成</strong>。即使 CPU 空闲，也不能运行。处于阻塞态的进程会排一个队列，或根据阻塞原因不同排多个队列。</li><li><strong>创建态：</strong> 正在被创建，尚未到就绪态。比如创建过程中资源没有得到满足的情况（如内存不足）。<ol><li>创建进程的步骤：<ol><li>申请空白 PCB，填写信息</li><li>分配资源</li><li>转入就绪态，插入就绪队列</li></ol></li></ol></li><li><strong>终止态：</strong> 进程正在消失，可能是正常结束或者是其他原因。进程需要结束时，系统先将其设置为终止态，然后释放资源、回收等。</li></ol><p><strong>注意区分就绪态和阻塞态</strong>。就绪态的进程仅缺少 CPU，阻塞态的进程需要其他资源或者等待某个事件。</p><ul><li><strong>三种基本状态的转换：</strong><ul><li><strong>就绪态 → 运行态：</strong> 处于就绪态的进程被调度后，<strong>获得 CPU 资源</strong>（被分派 CPU 时间片），从而状态转换。</li><li><strong>运行态 → 就绪态：</strong> 处于运行态的进程时间片用完后<strong>让出 CPU。</strong> 在可剥夺的操作系统中，有<strong>更高优先级的进程就绪</strong> 的时候，调度程序将正在执行的进程转为就绪态，让更高优先级的进程执行。</li><li><strong>运行态 → 阻塞态：</strong> 进程<strong>请求某一资源（如外设）的使用和分配</strong> ，或者<strong>等待某事件发生（如 I&#x2F;O 操作的完成）</strong> ，从运行态转为阻塞态。</li><li><strong>阻塞态 → 就绪态：进程等待的事件到来的时候（如 I&#x2F;O 完成或中断结束）</strong> ，<strong>中断处理程序</strong> 必须将相应进程的状态由阻塞态转为就绪态。</li></ul></li></ul><p>一个进程由运行态到阻塞态是主动的行为，而从阻塞态转为就绪态是被动的行为，需要其他进程协助。</p><p>就绪态和运行态之间是相互的，其他是单向。</p><p><img src="https://shingeki-pic.oss-cn-nanjing.aliyuncs.com/img/20250402110245905.png"></p><h3 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h3><p>一般将进程控制用的程序段称为原语，执行期间不允许中断。</p><ul><li><p><strong>进程的创建</strong></p><ul><li>允许一个进程创建另一个进程，创建者为父进程，被创建者为子进程。<strong>子进程可以继承父进程的资源，子进程被撤销时，资源应还给父进程。撤销父进程时通常同时撤销所有子进程。（20）</strong>（似乎存在例外，真题里面有提到，不一定撤销其子进程）</li><li><strong>导致进程创建的操作：（10）</strong><ul><li>终端用户登录系统</li><li>作业调度</li><li>系统提供服务</li><li>用户程序的应用请求</li><li>…</li></ul></li><li><strong>创建新进程的操作：（21）</strong><ol><li><strong>分配一个唯一的进程标识号，申请一个空白 PCB</strong>。若 PCB 申请失败则创建失败。</li><li><strong>分配运行所需资源</strong>，如内存、文件、I&#x2F;O 设备、CPU 时间等（在 PCB 中体现）。资源的来源为操作系统或父进程。若资源不足，则进程为<strong>创建态</strong>，等待资源，<strong>并不会失败</strong>。</li><li><strong>初始化 PCB</strong>，包括标志信息、CPU 状态信息、CPU 控制信息、进程优先级等。</li><li>若就绪队列能够接纳新进程，则进入就绪队列等待调度。</li></ol></li></ul></li><li><p><strong>进程的终止</strong></p><ul><li><strong>引起终止的事件</strong><ul><li>正常结束</li><li>异常结束，如存储区越界、保护错、非法指令、特权指令错、运行超时、算术运算错、I&#x2F;O 故障等</li><li>外界干预，包括操作员、操作系统干预、父进程请求、父进程终止。</li></ul></li><li><strong>终止进程时的操作（24）</strong><ol><li>根据标识符检索出 PCB，读取进程状态。</li><li>若处于运行态，立即终止执行，分配 CPU 资源给其他进程。</li><li>若还有子孙进程，通常需要将所有子孙进程终止。</li><li>将进程全部资源归还给<strong>父进程或操作系统</strong>。</li><li>将 PCB 从<strong>队列或链表</strong>中删除。</li></ol></li></ul></li><li><p><strong>进程的阻塞和唤醒（14 19 18 22 23）</strong></p><ul><li>进程由于期待事件未发生或无新任务可做，调用阻塞原语，将自身从运行态变为阻塞态。这是<strong>主动行为</strong>，也只有获得了 CPU 的运行态程序可以进入阻塞态。</li><li><strong>阻塞原语的执行过程：</strong><ol><li>找到进程标识号（PID）对应的 PCB</li><li>若为运行态，则保护现场，状态转为阻塞态，停止运行。</li><li>将 PCB 插入相应事件的等待队列，将 CPU 资源调度给其他就绪进程。</li></ol></li><li><strong>进程唤醒的事件和时机</strong><ul><li>期待的事件（IO 完成或期待数据到达等）出现时，有关进程调用唤醒原语。<ul><li><strong>唤醒原语的执行过程：</strong><ol><li>在该事件的等待队列中找到相应进程的 PCB</li><li>将其移出等待队列，状态改为就绪态。</li><li>PCB 插入就绪队列，等待调度</li></ol></li></ul></li><li>阻塞原语和唤醒原语必须成对使用。</li></ul></li></ul></li></ul><h3 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h3><p>PV 操作是低级通信方式。</p><ul><li>高级通信方式是以较高速率传输大量数据的通信方式。主要有下面三类。<ul><li><strong>共享存储</strong><ul><li>通信的进程之间存在一块可以直接访问的共享空间。</li><li>对共享空间的读写操作需要利用同步互斥工具（如 PV）进行控制。</li><li>进程空间一般是独立的，所以需要特殊系统调用实现共享。</li></ul></li><li><strong>消息传递</strong><ul><li>数据交换以格式化的信息为单位。</li><li>利用操作系统提供的发送消息和接收消息的原语进行数据交换。</li><li>对用户透明</li><li>微内核常用，微内核和服务器间通信</li></ul></li><li><strong>管道通信（2014）</strong><ul><li>管道是一个特殊的共享<strong>文件</strong>，数据在管道中<strong>先进先出</strong>。</li><li>管道通信允许两个进程按<strong>生产者-消费者</strong>方式进行通信，只要管道不满，写进程就能向管道写入数据；只要管道非空，读进程就能从管道读出数据。</li><li>管道应提供三方面协调能力：<ul><li><strong>互斥，<strong>同时只能有一个进程对管道读&#x2F;写。</strong>（14 一个管道只能有一个读进程或一个写进程对其操作 ✗ 可以有，但应避免。）</strong></li><li><strong>同步，</strong> 向管道写入一定量数据后，写进程阻塞，读进程读数据后唤醒。读进程读空管道后，读进程阻塞，写进程写入管道后唤醒。</li><li><strong>确定对方的存在。</strong></li></ul></li><li>Linux 中的常用通信机制。</li><li>管道也是一种文件。与普通文件通信相比，使用管道能够<strong>限制管道大小</strong>。Linux 中固定为 4KB，不会不加检验地增长。</li><li>管道只能由创建它的进程访问。父进程创建一个管道后，子进程会继承父进程的打开文件，同时也继承管道文件，可以用它与父进程通信。</li><li>从管道<strong>读数据是一次性操作</strong>。数据被读取后即被释放。</li><li>普通管道<strong>只允许单向通信</strong>，双向通信需要两个管道。</li></ul></li></ul></li></ul><h3 id="线程和多线程模型"><a href="#线程和多线程模型" class="headerlink" title="线程和多线程模型"></a>线程和多线程模型</h3><p>引入线程的目的：减小程序在并发执行时的时空开销，提高 OS 并发性能。</p><p>线程是一个基本的 CPU 执行单元，也是程序执行流的最小单元。</p><p>由<strong>线程 ID、程序计数器、寄存器集合和堆栈</strong>组成。</p><p>线程是<strong>进程中的一个实体</strong>，是被系统独立调度和分派的基本单位。</p><p>线程自己不拥有系统资源，只有一点在运行中必不可少的资源，但它可与<strong>同属于一个进程的其他线程</strong>共享所拥有的全部资源。</p><p>线程可以<strong>创建、撤销其他线程</strong>，同一进程中的多个线程可以并发。</p><p>线程间相互制约，导致运行中会出现间断性。所以线程有<strong>就绪、阻塞、运行</strong>三种状态。</p><p>引入线程后，进程只作为除了 CPU 以外的系统资源的分配单元，线程作为 CPU 的分配单元。</p><p>线程的切换若在进程内部，只需很小的时空开销。</p><ul><li><p><strong>线程和进程的比较（12）</strong></p><ul><li><strong>调度。</strong> 引入线程的 OS 中，线程是独立调度的基本单位，**线程切换的代价远低于进程。**传统 OS 中调度在进程之间，开销大。</li><li><strong>并发性。</strong> 引入线程的 OS 中，进程可并发，同一或不同进程的线程也可并发，提高了资源利用率和系统吞吐量。</li><li><strong>拥有的资源。</strong> 进程是拥有系统资源的基本单位，线程不拥有系统资源，只有一点在运行中必不可少的资源**。**但线程可以访问其隶属进程的系统资源。（同一进程的所有线程有相同的地址空间）</li><li><strong>独立性。</strong> 进程有独立地址空间和资源，除共享部分，不允许其他进程访问。某个进程中的线程对其他进程不可见，这些线程共享进程的地址空间和资源。</li><li><strong>系统开销。</strong> 创建或撤销进程的时候，系统要分配、回收 PCB 等资源，切换进程时也涉及上下文切换。线程切换时只要保存少量寄存器内容，开销小。线程间的同步和通信实现也更简单。</li><li><strong>支持多处理器系统。</strong> 多线程进程可以将多个线程分配到多个 CPU 上。</li><li>线程的提出提高系统并发性的理解：线程切换时，可能切换进程，也可能不切换，平均看来切换所需开销就变小。</li></ul></li><li><p><strong>线程的属性（11 24）</strong></p><ul><li>线程是一个轻型实体，不拥有系统资源，但每个线程都应有一个唯一标识符、一个线程控制块，线程控制块记录线程执行的寄存器和栈等现场状态。</li><li>不同线程可以执行相同的程序。即同一服务程序被不同用户调用时，OS 将为它们创建不同的线程。</li><li>同一进程中各个线程共享该进程的资源。</li><li>线程是 CPU 的独立调度单位，可以并发。</li><li>线程有其生命周期，有阻塞态 就绪态 运行态。<ul><li>运行态：线程获得 CPU，正在运行。</li><li>就绪态：已具备各种执行条件，只需要获得 CPU 就可以运行。</li><li>阻塞态：执行中因某时间受阻而暂停。</li><li>三种状态的转换与进程一致。</li></ul></li></ul></li><li><p><strong>线程的组织和控制（19 24）</strong></p><ul><li>线程控制块 TCB 包括：<ul><li>线程标识符</li><li>一组寄存器，包括 PC 状态寄存器和通用寄存器</li><li>线程运行状态</li><li>优先级</li><li>线程专有存储区，用于线程切换时保护现场</li><li>堆栈指针，用于过程调用时保存局部变量以及返回地址</li></ul></li><li>一个线程可以读写或清除另一个线程的堆栈。<strong>（11 进程 P 创建的若干线程不能共享进程 P 中某个线程的栈指针 这一部分是独享的）</strong></li><li>OS 中存在用于创建 终止线程的函数或系统调用。</li><li>用户程序启动时，通常仅有一个初始化线程正在执行，主要功能是创建新的线程。</li><li>有的线程被建立后，会一直运行而不被终止。</li><li>线程被终止后并不立即释放所拥有的资源。只有当进程中的其他线程执行分离函数之后，被终止的线程才与资源分离，资源才能被其他线程利用。</li><li>被终止但未被释放资源的线程可以被其他线程调用，使得被终止线程恢复运行。</li></ul></li><li><p><strong>线程的实现方式（19）</strong></p><ul><li>线程的实现分为两类<ul><li><strong>用户级线程（User-Level Thread ULT）</strong><ul><li>“用户视角能看到的线程”</li><li>线程创建撤销切换等所有工作都在<strong>用户态</strong>完成，内核不知道线程的存在。</li><li>应用程序从单线程开始，在该线程中开始运行，运行时可以调用线程库中的派生例程创建一个在相同进程中运行的新线程。<ul><li>线程库是为程序员提供的创建和管理线程的 API。比如 Pthreads、Windows API、Java</li></ul></li><li>设置了用户级线程的系统，调度仍然以进程为单位，各进程轮换时间片。若 A 进程线程少，B 进程线程多，A 进程中线程的执行时间则更长，对线程而言不公平。</li><li>优点<ul><li>线程切换<strong>不需要切换到内核态</strong>，节约模式切换的开销</li><li>调度算法可以是进程专用的，不同的进程可以根据需要选择自己的线程调度算法</li><li>用户级线程的实现是用户程序的一部分，与 OS 无关</li></ul></li><li>缺点<ul><li><strong>系统调用的阻塞问题</strong>。线程执行一个系统调用时，该线程以及进城内所有线程都被阻塞。</li><li><strong>不能发挥多 CPU 优势</strong>。进程中同时只有一个线程运行。</li></ul></li></ul></li><li><strong>内核级线程（Kernel-Level Thread KLT），<strong>又称</strong>内核支持的线程</strong><ul><li>线程管理的所有工作在<strong>内核态</strong>进行。</li><li>OS 给每个内核级线程设置一个 TCB。</li><li>优点<ul><li><strong>发挥多 CPU 优势</strong>，同一进程的多线程能并发。</li><li>进程中的一个线程被阻塞时，进程的其他线程可以占用 CPU，也可以运行其他进程中的线程。</li><li>内核支持线程有很小的数据结构和堆栈，<strong>切换快，开销小</strong>。</li><li>内核本身可以采用多线程技术，提高系统执行速度和效率。</li></ul></li><li>缺点<ul><li>同一进程中的线程切换需要从用户态到内核态，开销较大。这是因为用户进程的线程在用户态运行，但调度和管理是在内核态。</li></ul></li></ul></li><li><strong>组合方式</strong><ul><li>内核支持多个内核级线程的管理，也允许用户管理用户级线程。综合上面优点，克服上面缺点。</li><li>用户级线程和内核级线程的连接方式<ul><li>多对一模型<ul><li>多个用户级线程映射到一个内核级线程。</li><li>线程管理在用户态 效率高</li><li>一个线程被阻塞会导致整个进程的阻塞。多个线程不能分到多个 CPU 上。</li></ul></li><li>一对一模型<ul><li>每个用户级线程映射到一个内核级线程。</li><li>线程被阻塞后，允许调度另一个线程，并发能力较强</li><li>每创建一个用户线程，就需要创建一个内核线程，开销大。</li></ul></li><li>多对多模型<ul><li>n 个用户级线程映射到 m 个内核级模型，n &gt;&#x3D; m</li><li>综合上面优点，克服上面缺点。</li></ul></li></ul></li></ul></li></ul></li></ul></li></ul><h2 id="CPU-调度"><a href="#CPU-调度" class="headerlink" title="CPU 调度"></a>CPU 调度</h2><p>调度的层次（没考过，略）</p><h3 id="调度的实现"><a href="#调度的实现" class="headerlink" title="调度的实现"></a>调度的实现</h3><ul><li><p>调度程序</p><ul><li>排队器<ul><li>按策略将就绪进程排队</li></ul></li><li>分派器<ul><li>将 CPU 分配给新进程</li></ul></li><li>上下文切换器<ul><li>两对上下文切换：<ul><li>当前进程上下文存到其 PCB 里，装入分派程序的上下文，使分派程序运行</li><li>移出分派程序上下文，将新选进程的 CPU 现场信息装入各寄存器</li></ul></li></ul></li></ul></li><li><p><strong>调度的时机、切换与过程</strong></p><ul><li><strong>现代 OS 中，应该进行进程调度与切换的情况如下：（12 21）</strong><ul><li>创建新进程后，由于父进程和子进程都在就绪态，因此需要决定运行父进程还是子进程。此时由调度程序决定。</li><li>进程正常结束或异常终止后，必须从就绪队列中选择进程运行。若没有就绪进程则运行闲逛进程。<ul><li>闲逛进程优先级最低，不需要 CPU 以外的资源，不会被阻塞</li></ul></li><li>进程因 I&#x2F;O 请求 PV 操作等被阻塞时，需要调度其他进程。</li><li>IO 设备完成后，发出 IO 中断，原先等待 IO 的进程变为就绪态，此时需要决定是让新的就绪进程运行还是中断发生时的进程继续运行。</li><li>有些系统中，有更高优先级的进程进入就绪队列需要处理时，也被强行剥夺 CPU。</li></ul></li><li>进程切换在调度完成后立刻发生。要求保存原进程当前断点的现场，恢复被调度进程的现场。</li><li><strong>不能进行进程的调度与切换的情况：</strong><ul><li>处理中断的过程中。</li><li>需要完全屏蔽中断的原子操作过程中。</li></ul></li></ul></li><li><p><strong>进程调度的方式</strong></p><ul><li>非抢占调度，当有优先级更高的进程进入就绪队列，仍然让进程继续执行直到正常结束、异常终止或者进入阻塞态。</li><li>抢占调度，更高优先级的进程会抢占 CPU</li></ul></li><li><p><strong>两种线程的调度</strong></p><ul><li>用户级线程调度：进程中的调度程序决定哪个线程运行，只需要少量机器指令</li><li>内核级线程调度：内核选择一个特定线程运行，通常不考虑属于哪个进程。给选中线程赋予一个时间片。需要完整的上下文切换、修改内存影像、使高速缓存失效，延迟高。</li></ul></li></ul><h3 id="调度的相关计算（12-16-18-19-23-24）"><a href="#调度的相关计算（12-16-18-19-23-24）" class="headerlink" title="调度的相关计算（12 16 18 19 23 24）"></a>调度的相关计算（12 16 18 19 23 24）</h3><p><strong>CPU 利用率：</strong> CPU 有效工作时间 ÷（CPU 有效工作时间 +CPU 空闲时间）</p><p>计算作业完成时间的时候，要注意 CPU 与设备、设备之间可以<strong>并行</strong>。</p><p><strong>系统吞吐量：</strong> 单位时间内 CPU 完成作业的数量。</p><p><strong>周转时间：</strong> 作业完成时间-作业提交时间，是作业等待、在就绪队列中排队、在 CPU 上运行、IO 操作花费时间总和。<strong>（不是运行时间）</strong></p><p><strong>平均周转时间</strong> 是多个作业周转时间直接取平均。</p><p><strong>带权周转时间</strong> ：作业周转时间 ÷ 作业实际运行时间（？这不是个比值？为啥叫时间？）<strong>（注意分子分母）</strong></p><p><strong>平均带权周转时间</strong> 是多个作业带权周转时间直接取平均。</p><p><strong>等待时间：</strong> 是指进程处于等待 CPU 的时间之和。</p><p><strong>响应时间：</strong> 指从用户提交请求到系统首次响应的时间。</p><h3 id="进程切换"><a href="#进程切换" class="headerlink" title="进程切换"></a>进程切换</h3><p>对于通常进程而言，其创建、撤销、以及要求由系统设备完成的 IO 操作都是<strong>利用系统调用进入内核</strong>，内核中的处理程序完成的。进程切换也是在<strong>内核</strong>的支持下实现的。<strong>（23）</strong></p><p>调度和切换的区别：调度是指决定资源分配给谁的行为，是决策；切换是实际分配过程，是执行。先有资源调度，后有进程切换。</p><ul><li><p><strong>切换进程的操作（上下文切换）（24）</strong></p><ul><li>挂起一个进程，将 CPU 上下文保存到 PCB，包括 PC 和其他寄存器。</li><li>将进程 PCB 移入相应队列，如就绪、阻塞队列</li><li>选择另一个进程执行，<strong>更新其 PCB</strong></li><li>恢复新进程的 CPU 上下文</li><li>跳转到新进程 PCB 中的 <strong>PC 指向的位置</strong>执行。</li></ul></li><li><p>上下文切换的消耗</p><ul><li>计算密集型，需要大量 CPU 时间。但有的 CPU 提供多个寄存器组，此时只需改变寄存器组指针。</li></ul></li><li><p>上下文切换和模式切换</p><ul><li>模式切换时，CPU 逻辑上可能还在执行同一进程。进程运行可能从用户态进入内核态再返回。</li><li>上下文切换<strong>只发生在内核态。</strong></li></ul></li></ul><h4 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h4><p>各种算法的特点和对比（<strong>09 11 14</strong>）</p><ul><li><p><strong>先来先服务（FCFS）调度算法（17）</strong></p><ul><li>进程调度中，FCFS 算法每次从就绪队列中选择最先进入该队列的进程，将 CPU 分配给它，直到运行结束或者被阻塞。</li><li>作业调度同理。</li><li>FCFS 属于不可剥夺算法。</li><li>特点：算法简单；效率低；对长作业有利，对短作业不利（相对于 SJF 和高响应比）；有利于 CPU 繁忙型作业，不利于 IO 繁忙型作业。</li></ul></li><li><p><strong>短作业优先（SJF shortest job first）（17）</strong></p><ul><li>短作业优先（SJF）调度：从后备队列中选择<strong>一个或者几个</strong>估计运行时间最短的作业，调入内存运行</li><li>短进程优先（SPF）调度：从就绪队列中选<strong>一个</strong>估计运行时间最短的进程分配 CPU。</li><li>算法对长作业不利，有可能导致长作业长期不被调度，产生饥饿现象。<ul><li>饥饿是调度策略问题，死锁是系统环形等待，注意区分<strong>饥饿和死锁</strong>。（16）</li></ul></li><li>SPF 算法默认非抢占式，但也可以是抢占式的。规则是新进程的执行时间比当前进程<strong>剩余</strong>时间小，则抢占。</li></ul></li><li><p><strong>高响应比优先调度算法</strong></p><ul><li>主要用于作业调度。每次调度时先计算作业队列中每个的响应比，选最高的投入运行。</li><li><strong>响应比 &#x3D; (等待时间 + 要求服务时间) &#x2F; 要求服务时间</strong></li><li>等待时间相同时，要求服务时间越短，响应比越高，有利于短作业</li><li>要求服务时间相同时，等待时间越长，响应比越高，可以克服饥饿现象。</li></ul></li><li><p><strong>优先级调度算法（10 13 16 18 22 23）</strong></p><ul><li>可以用于作业调度和进程调度。分为抢占式和非抢占式。优先级可变或不可变。</li><li>优先级设置一般<ul><li>系统进程 &gt; 用户进程</li><li>交互型进程 ＞ 非交互型进程（或 前台 ＞ 后台）</li><li>I&#x2F;O 型进程 &gt; 计算型进程（13）<ul><li>I&#x2F;O 进程指频繁使用 I&#x2F;O 设备的进程，计算型进程指频繁使用 CPU 的进程</li><li>I&#x2F;O 设备处理速度慢，要让其尽早开始工作。</li></ul></li></ul></li></ul></li><li><p><strong>时间片轮转（RR）调度算法（17 21 24）</strong></p><ul><li>主要适用于分时系统。系统将所有的就绪进程按 FCFS 策略排成就绪队列，系统每隔一段时间产生一次时钟中断，激活调度程序调度，将 CPU 分配给队首进程，执行一个时间片。</li><li><strong>时间片执行完后，产生一个时钟中断，激活调度程序。若进程没有运行完，则释放 CPU 给新的队首进程，自己到队尾重新排队。</strong></li><li><strong>若时间片没有用完而进程已经运行完，调度程序立即被激活。</strong></li><li>对时间片大小的分析：<ul><li>若时间片够大，所有进程都能在一个时间片内执行完，则退化为 FCFS 算法</li><li>若时间片过小，则 CPU 频繁切换，开销很大。</li><li>时间片的大小应该由系统的相应事件、就绪队列的进程数目和系统的处理能力决定。</li></ul></li></ul></li><li><p><strong>多级队列调度算法</strong></p><ul><li>设置多个就绪队列，将不同类型或性质的进程分到各个就绪队列，每个队列实施不同的调度算法。</li><li>同一队列中的进程可以设置优先级，不同队列也可以设置优先级。</li><li>多 CPU 中，可以为每个 CPU 设置一个单独的就绪队列，每个 CPU 实施不同调度策略，这样就可以根据用户需求将多个线程分配到一个或多个 CPU 上运行。</li></ul></li><li><p><strong>多级反馈队列调度算法（综合各算法优点）（19 20）</strong></p><ul><li>动态调整进程优先级和时间片大小，兼顾多方面系统目标</li><li>比如为提高系统吞吐量、缩短平均周转时间照顾短进程</li><li>比如为获得较好的 I&#x2F;O 设备利用率、缩短响应时间照顾 I&#x2F;O 进程</li><li>不必事先估计进程执行时间</li><li><strong>实现思想：</strong><ul><li>设置多个就绪队列，为每个队列赋予不同优先级。</li><li>赋予各个队列的进程运行时间片的大小不同。优先级越高的队列中，时间片越小。</li><li>每个队列采用 FCFS 算法。首先放入第 1 级队列的末尾，等待调度。轮到其执行时，若未完成，则进入第 2 级队列末尾，以此类推。</li><li>仅第 1 ~ i - 1 级队列为空时，调度第 i 级队列中进程运行。</li><li>如果 CPU 执行第 i 级队列中进程时，新进程进入优先级更高的队列，此时立即将正在运行的进程放入第 i 级队列末尾，执行新的进程。</li></ul></li><li><strong>优势：</strong><ul><li>对于终端型作业用户，短作业优先（？）<ul><li>GPT：终端型作业是交互式的，用户可以直接与系统进行交互。用户在终端（如命令行界面）输入命令，系统立即处理并返回结果。</li></ul></li><li>对于短批处理作业用户，周转时间较短</li><li>对于长批处理作业用户，经过前面几个队列得到部分执行，不会长期得不到处理。</li></ul></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
            <tag> OS </tag>
            
            <tag> 考研 </tag>
            
            <tag> 进程 </tag>
            
            <tag> 线程 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
