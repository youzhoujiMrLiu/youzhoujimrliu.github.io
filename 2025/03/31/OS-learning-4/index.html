<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>王道OS看书笔记——I/O管理 | shingeki的博客</title><meta name="author" content="shingeki"><meta name="copyright" content="shingeki"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="本文为我考研期间看王道书时写的飞书笔记，根据各知识点的逻辑关系进行整理，添加了一点自己的理解，内容不如王道书全。">
<meta property="og:type" content="article">
<meta property="og:title" content="王道OS看书笔记——I&#x2F;O管理">
<meta property="og:url" content="https://youzhoujimrliu.github.io/2025/03/31/OS-learning-4/index.html">
<meta property="og:site_name" content="shingeki的博客">
<meta property="og:description" content="本文为我考研期间看王道书时写的飞书笔记，根据各知识点的逻辑关系进行整理，添加了一点自己的理解，内容不如王道书全。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://shingeki-pic.oss-cn-nanjing.aliyuncs.com/img/20250402113113735.jpg">
<meta property="article:published_time" content="2025-03-31T15:42:14.000Z">
<meta property="article:modified_time" content="2025-04-04T15:52:23.382Z">
<meta property="article:author" content="shingeki">
<meta property="article:tag" content="操作系统">
<meta property="article:tag" content="OS">
<meta property="article:tag" content="考研">
<meta property="article:tag" content="I&#x2F;O管理">
<meta property="article:tag" content="I&#x2F;O">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://shingeki-pic.oss-cn-nanjing.aliyuncs.com/img/20250402113113735.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "王道OS看书笔记——I/O管理",
  "url": "https://youzhoujimrliu.github.io/2025/03/31/OS-learning-4/",
  "image": "https://shingeki-pic.oss-cn-nanjing.aliyuncs.com/img/20250402113113735.jpg",
  "datePublished": "2025-03-31T15:42:14.000Z",
  "dateModified": "2025-04-04T15:52:23.382Z",
  "author": [
    {
      "@type": "Person",
      "name": "shingeki",
      "url": "https://youzhoujimrliu.github.io/"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://youzhoujimrliu.github.io/2025/03/31/OS-learning-4/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: false,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '王道OS看书笔记——I/O管理',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="web_bg" style="background: linear-gradient(9deg, rgba(122,167,255,0.8487044475993523) 10%, rgba(107,9,121,0.7394607501203607) 65%, rgba(255,163,0,0.5209733551623774) 100%);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="https://shingeki-pic.oss-cn-nanjing.aliyuncs.com/img/20250402112624099.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">7</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">31</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://shingeki-pic.oss-cn-nanjing.aliyuncs.com/img/20250402113113735.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">shingeki的博客</span></a><a class="nav-page-title" href="/"><span class="site-name">王道OS看书笔记——I/O管理</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">王道OS看书笔记——I/O管理</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-03-31T15:42:14.000Z" title="发表于 2025-03-31 23:42:14">2025-03-31</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-04-04T15:52:23.382Z" title="更新于 2025-04-04 23:52:23">2025-04-04</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><p>本文为我考研期间看王道书时写的飞书笔记，根据各知识点的逻辑关系进行整理，添加了一点自己的理解，内容不如王道书全。</p>
<h2 id="I-O管理概述"><a href="#I-O管理概述" class="headerlink" title="I&#x2F;O管理概述"></a>I&#x2F;O管理概述</h2><h3 id="I-O设备"><a href="#I-O设备" class="headerlink" title="I&#x2F;O设备"></a>I&#x2F;O设备</h3><ul>
<li><p>按信息交换的单位分类</p>
<ul>
<li><strong>块设备</strong><ul>
<li>信息交换以数据块为单位，如磁盘 磁带等</li>
<li>传输速率高 可寻址（随机读写任意一块）</li>
</ul>
</li>
<li><strong>字符设备</strong><ul>
<li>信息交换以字符为单位，如交互式终端机、打印机等</li>
<li>传输速率低 不可寻址 时常采用中断I&#x2F;O方式</li>
</ul>
</li>
</ul>
</li>
<li><p>按设备使用特性分类</p>
<ul>
<li>存储设备<ul>
<li>硬盘 磁带 光盘等</li>
</ul>
</li>
<li>输入输出设备<ul>
<li>键盘 鼠标 扫描仪 打印机 触控显示器</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>I&#x2F;O接口（设备控制器）</strong></p>
<ul>
<li>CPU和设备之间的接口，实现设备和计算机的数据交换</li>
<li>接收CPU的命令，控制设备工作<br><img src="https://shingeki-pic.oss-cn-nanjing.aliyuncs.com/img/20250402111815713.png"></li>
<li>设备控制器与CPU的接口<ul>
<li>实现CPU和设备控制器之间的通信</li>
<li>有三类信号线<ul>
<li>数据线 传送读写数据 控制信息和状态信息</li>
<li>地址线 传送要访问I&#x2F;O接口中的寄存器编号</li>
<li>控制线 传送读写等控制信号</li>
</ul>
</li>
</ul>
</li>
<li>设备控制器和设备的接口<ul>
<li>一个设备控制器可以连接一个&#x2F;多个设备，控制器中有一个&#x2F;多个设备接口</li>
<li>每个接口都可以传输数据 控制 状态信号</li>
</ul>
</li>
<li>I&#x2F;O逻辑<ul>
<li>实现对设备的控制</li>
<li>通过一组控制线和CPU交互，对收到的I&#x2F;O命令译码</li>
</ul>
</li>
<li>设备控制器主要功能<ul>
<li>接收 识别命令</li>
<li>数据交换</li>
<li>标识和报告设备状态</li>
<li>地址识别</li>
<li>数据缓冲</li>
<li>差错控制</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>I&#x2F;O端口</strong></p>
<ul>
<li>指设备控制器中可被CPU直接访问的<strong>寄存器</strong><ul>
<li>数据寄存器</li>
<li>状态寄存器</li>
<li>控制寄存器</li>
</ul>
</li>
<li>I&#x2F;O端口需要对各个端口编址使得能够被CPU访问<ul>
<li>编址方式有与存储器独立编址和统一编址两种<br><img src="https://shingeki-pic.oss-cn-nanjing.aliyuncs.com/img/20250402111828441.png"><ul>
<li><strong>独立编址</strong><ul>
<li>每个端口分配一个I&#x2F;O端口号</li>
<li>I&#x2F;O端口地址空间和主存地址空间是两个独立的地址空间<ul>
<li>它们的范围可以重叠<ul>
<li>GPT: 虽然I&#x2F;O端口和主存各自有独立的地址空间，但它们的地址范围可能存在<strong>重叠</strong>。例如，在某些架构中，<strong>I&#x2F;O设备可能使用与主存相同的物理地址</strong>，但操作系统和硬件通过不同的机制区分这些地址。<strong>重叠并不意味着冲突</strong>，因为通过特定的指令或访问方式（如通过I&#x2F;O指令或内存读写指令）来区分是访问I&#x2F;O设备还是访问主存。</li>
</ul>
</li>
<li>相同地址可能属于不同的地址空间<ul>
<li>GPT: <strong>相同地址</strong>指的是某个数值可以出现在I&#x2F;O地址空间中，也可以出现在主存地址空间中。例如，地址<code>0x1000</code>既可以是一个内存地址，也可以是一个I&#x2F;O端口地址。操作系统或CPU通过不同的指令集（如<code>IN</code>和<code>OUT</code>用于I&#x2F;O操作，<code>MOV</code>用于内存操作）来确定是访问哪个地址空间。</li>
</ul>
</li>
</ul>
</li>
<li><strong>优点：</strong><ul>
<li>I&#x2F;O端口数比主存单元少得多，只需少量地址线，使得I&#x2F;O端口译码简单，寻址速度更快</li>
<li>使用专用I&#x2F;O指令，程序更加清晰，便于理解检查</li>
</ul>
</li>
<li><strong>缺点：</strong><ul>
<li>I&#x2F;O指令少，只提供简单的传输操作，程序设计灵活性较差</li>
<li>CPU需要提供两组独立的存储器和设备的读写控制信号，增加控制复杂性</li>
</ul>
</li>
</ul>
</li>
<li><strong>统一编址</strong><ul>
<li>又称内存映射I&#x2F;O</li>
<li>将主存地址空间分出一部分给I&#x2F;O端口编址</li>
<li>I&#x2F;O端口和主存单元在同一地址空间不同分段中</li>
<li>根据地址范围就能区分访问的是I&#x2F;O端口还是主存单元，不需要专门I&#x2F;O指令</li>
<li><strong>优点：</strong><ul>
<li>不需要专门的I&#x2F;O指令，CPU访问I&#x2F;O更加灵活</li>
<li>端口有较大编制空间</li>
<li>I&#x2F;O访问的保护机制由虚拟存储管理系统实现，无需专门设置</li>
</ul>
</li>
<li><strong>缺点</strong><ul>
<li>端口地址占用了部分主存地址空间，主存可用容量变小</li>
<li>识别I&#x2F;O时，全部地址线参加译码，译码电路更复杂，降低了寻址速度</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="I-O控制方式"><a href="#I-O控制方式" class="headerlink" title="I&#x2F;O控制方式"></a>I&#x2F;O控制方式</h3><ul>
<li><p><strong>I&#x2F;O控制</strong>是指控制设备和主机之间的数据传送</p>
</li>
<li><p>要求尽量减少CPU对I&#x2F;O控制的干预，更多地执行运算任务</p>
</li>
<li><p><strong>3种I&#x2F;O控制方式</strong><br><img src="https://shingeki-pic.oss-cn-nanjing.aliyuncs.com/img/20250402111835776.png"></p>
<ul>
<li><strong>程序直接控制方式</strong><ul>
<li>CPU对I&#x2F;O设备的控制采取<strong>轮询</strong>的I&#x2F;O方式</li>
<li>又称程序轮询方式</li>
<li><strong>过程</strong><ul>
<li>CPU向设备控制器发出一条I&#x2F;O指令，从I&#x2F;O设备读一个字（节）</li>
<li>不断地循环测试设备状态，直到确定该字（节）已在设备控制器的数据寄存器里</li>
<li>CPU将数据寄存器中数据取出，送入内存指定单元</li>
</ul>
</li>
<li>优点：简单易于实现</li>
<li>缺点：<ul>
<li>CPU绝大部分时间都在轮询，CPU和I&#x2F;O设备只能串行工作<ul>
<li>CPU和I&#x2F;O设备速度差距大，导致CPU利用率很低</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><strong>中断驱动方式（10 17 23 24）</strong><ul>
<li>允许I&#x2F;O设备主动打断CPU运行并请求服务</li>
<li>CPU向设备控制器发出一条I&#x2F;O指令后可以继续做其他工作</li>
<li><strong>设备控制器角度的过程</strong><ul>
<li>设备控制器从CPU接收一个读命令，从设备读数据</li>
<li>读入数据寄存器后，通过控制线给CPU发出中断信号，表示数据已经准备好</li>
<li>等待CPU请求数据</li>
<li>收到CPU取数据请求后，将数据放到数据总线上，传到CPU寄存器中</li>
</ul>
</li>
<li><strong>CPU角度的过程</strong><ul>
<li>当前运行进程发出读命令，进程被阻塞，保存上下文，执行其他程序</li>
<li>每个指令周期的末尾，CPU检查中断信号</li>
<li>有来自设备控制器的中断时，CPU保存当前运行进程的上下文，执行中断处理程序</li>
<li>此时CPU从设备控制器读一个字的数据传送到寄存器，并存入主存</li>
<li>中断处理完后解除发出I&#x2F;O命令的进程的阻塞状态，恢复该进程（或其他进程）的上下文</li>
</ul>
</li>
<li><strong>优点：</strong><ul>
<li>CPU和设备并行工作，CPU利用率明显提升</li>
</ul>
</li>
<li><strong>缺点：</strong><ul>
<li>设备和内存之间数据交换必须经过CPU中寄存器</li>
<li>CPU以字（节）为单位干预，若用于块设备的I&#x2F;O操作，效率很低</li>
</ul>
</li>
</ul>
</li>
<li><strong>DMA方式（17）</strong><ul>
<li>DMA（Direct Memory Access，直接存储器存取）<br><img src="https://shingeki-pic.oss-cn-nanjing.aliyuncs.com/img/20250402111843178.png"></li>
<li>在<strong>I&#x2F;O设备和内存之间</strong>开辟直接的数据交换通路</li>
<li>特点<ul>
<li>基本传送单位是数据块</li>
<li>传送的数据从设备直接送入内存，或者相反，不经过CPU</li>
<li>仅在传送一个或多个数据块的开始和结束时，需要CPU干预</li>
</ul>
</li>
<li>为了实现主机和控制器之间直接交换成块的数据，需要在DMA控制器中设置4类寄存器：<ul>
<li>命令&#x2F;状态寄存器（CR）<ul>
<li>接收从CPU发来的I&#x2F;O命令 有关的控制信息 设备的状态</li>
</ul>
</li>
<li>内存地址寄存器（MAR）<ul>
<li>输入时，存放数据存放到内存的起始目的地址</li>
<li>输出时，存放内存源地址</li>
</ul>
</li>
<li>数据寄存器（DR）<ul>
<li>暂存I&#x2F;O设备到内存或者内存到设备的数据</li>
</ul>
</li>
<li>数据计数器（DC）<ul>
<li>存放传送字（节）数</li>
</ul>
</li>
</ul>
</li>
<li><strong>工作流程</strong><ul>
<li>CPU接收到设备的DMA请求时<ul>
<li>向DMA控制器发出命令，设置MAR和DC初值，启动DMA控制器，然后继续其他工作</li>
</ul>
</li>
<li>之后CPU将I&#x2F;O控制权交给DMA控制器，由DMA控制器负责数据传送<ul>
<li>DMA控制器直接和内存交互，每次传送一个字，不需要CPU参与</li>
</ul>
</li>
<li>整个数据传送结束后，DMA控制器向CPU发一个中断信号<ul>
<li>结束后才有中断，中断的作用是通知CPU</li>
</ul>
</li>
<li>只有传送开始和结束才有CPU参与</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="I-O软件层次结构"><a href="#I-O软件层次结构" class="headerlink" title="I&#x2F;O软件层次结构"></a>I&#x2F;O软件层次结构</h3><ul>
<li><p>使复杂的I&#x2F;O软件具有清晰的结构 良好的可移植性和易适应性</p>
</li>
<li><p>每层利用下层提供的服务，完成I&#x2F;O中某些子功能，屏蔽实现细节，向高层提供服务</p>
</li>
</ul>
<p><img src="https://shingeki-pic.oss-cn-nanjing.aliyuncs.com/img/20250402111850103.png"></p>
<ul>
<li><p><strong>用户层软件</strong></p>
<ul>
<li>实现与用户交互的接口，用户可以直接调用在用户层提供的、与I&#x2F;O操作有关的库函数</li>
<li>大部分I&#x2F;O软件都在OS内核，但仍有一部分在用户层</li>
<li>用户层I&#x2F;O软件必须通过一组系统调用获取OS服务</li>
</ul>
</li>
<li><p><strong>设备独立性软件（20）</strong></p>
<ul>
<li>实现用户程序与设备驱动器的统一接口、设备命名、设备保护以及设备的分配与释放等</li>
<li>同时为设备管理和数据传送提供必要的存储空间</li>
<li><strong>设备独立性</strong><ul>
<li>也称<strong>设备无关性</strong></li>
<li>含义：应用程序所用的设备不局限于某个具体的物理设备</li>
<li>为了实现设备独立性，引入逻辑设备和物理设备的概念<ul>
<li>应用程序使用逻辑设备名请求使用某些设备</li>
<li>系统实际执行时，将逻辑设备名映射成物理设备名<ul>
<li>使用逻辑设备名的好处<ul>
<li>增加设备分配灵活性</li>
<li>易于实现I&#x2F;O重定向<ul>
<li>含义: 用于I&#x2F;O操作的设备可以更换，而不必改变应用程序</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>设备独立性软件主要功能<ul>
<li>执行所有设备的公有操作，比如设备分配回收、逻辑设备名映射成物理设备名等</li>
<li>向用户层（文件层）提供统一接口，比如各种设备的读写统一使用read&#x2F;write命令</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>设备驱动程序</strong></p>
<ul>
<li>与硬件直接相关，负责具体实现系统对设备发出的操作指令，驱动I&#x2F;O设备工作</li>
<li>每类设备配置一个驱动</li>
<li>驱动是<strong>I&#x2F;O进程和设备控制器之间的通信</strong>程序，通常以<strong>进程</strong>的形式存在</li>
<li>向上层用户程序提供一组标准接口</li>
<li>将设备控制器发来的信号传送给上层软件</li>
</ul>
</li>
<li><p><strong>中断处理程序</strong></p>
<ul>
<li>保存被中断进程的CPU环境，转入相应中断处理程序进行处理，处理完毕，恢复现场，返回原进程</li>
</ul>
</li>
<li><p><strong>磁盘I&#x2F;O操作中各层次的处理过程（以读操作为例）</strong></p>
<ul>
<li>用户读取某设备内容时，通过OS提供的read接口（<strong>用户层</strong>）</li>
<li>用户发出的read命令经过<strong>设备独立层</strong>进行解析，交给下层</li>
<li>不同类型设备对于read命令行为有所不同，需要针对不同设备解析成不同指令（<strong>设备驱动层</strong>）</li>
<li>解析完毕后，需要中断正在运行的进程，转而执行read命令（<strong>中断处理程序</strong>）</li>
<li>命令真正抵达硬件设备，硬件设备控制器按照命令操控硬件（<strong>硬件</strong>）</li>
</ul>
</li>
</ul>
<h3 id="应用程序I-O接口"><a href="#应用程序I-O接口" class="headerlink" title="应用程序I&#x2F;O接口"></a>应用程序I&#x2F;O接口</h3><p>指I&#x2F;O系统与高层（应该是应用层？）的接口</p>
<ul>
<li><p><strong>I&#x2F;O接口分类</strong></p>
<ul>
<li>字符设备接口<ul>
<li>get&#x2F;put操作<ul>
<li>字符设备不可寻址，只能顺序存取</li>
<li>通常建立一个字符缓冲区，用户程序通过get操作从缓冲区获取字符，put操作输入到缓冲区</li>
</ul>
</li>
<li>in-control指令<ul>
<li>通用指令，参数多，功能多</li>
</ul>
</li>
<li>字符设备都属于独占设备，还需要提供打开和关闭操作，实现互斥共享</li>
</ul>
</li>
<li>块设备接口</li>
<li>网络设备接口</li>
</ul>
</li>
<li><p>阻塞I&#x2F;O和非阻塞I&#x2F;O</p>
<ul>
<li>阻塞I&#x2F;O<ul>
<li>用户进程调用I&#x2F;O操作时，进程被阻塞</li>
<li>实现简单，适合并发量小</li>
<li>但可能一直被阻塞</li>
</ul>
</li>
<li>非阻塞I&#x2F;O<ul>
<li>不阻塞该进程，但进程需要轮询I&#x2F;O操作是否完成</li>
<li>I&#x2F;O执行阶段，进程可以做其他事情</li>
<li>适合并发量大的应用开发</li>
<li>但轮询会占用CPU时间</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="设备独立性软件"><a href="#设备独立性软件" class="headerlink" title="设备独立性软件"></a>设备独立性软件</h2><ul>
<li>定义见上I&#x2F;O软件层次结构部分</li>
</ul>
<h3 id="高速缓存和缓冲区"><a href="#高速缓存和缓冲区" class="headerlink" title="高速缓存和缓冲区"></a>高速缓存和缓冲区</h3><ul>
<li><p><strong>磁盘高速缓存（15）</strong></p>
<ul>
<li>OS中利用磁盘高速缓存提高磁盘I&#x2F;O速度</li>
<li>例如，正在运行进程的数据既存在硬盘上，也存在内存里以及CPU的二级、一级高速缓存里</li>
<li><strong>磁盘高速缓存技术与CPU和内存之间的小容量高速缓存器不同</strong><ul>
<li>指的是利用内存暂存磁盘中信息</li>
</ul>
</li>
<li>逻辑上属于磁盘，物理上是驻留在内存中的盘块</li>
<li>在内存中，有两种形式<ul>
<li>在内存中开辟一个单独的空间作为缓冲区，大小固定</li>
<li>将未利用的内存空间作为一个缓冲池，供请求分页系统和磁盘I&#x2F;O时共享</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>缓冲区（11 13）</strong></p>
<ul>
<li>在设备管理中，引入缓冲区的目的<ul>
<li>缓和CPU和I&#x2F;O设备速度不匹配的矛盾</li>
<li>减少对CPU的中断频率，放宽对CPU中断响应时间的限制</li>
<li>解决基本数据单元大小（数据粒度）不匹配的问题</li>
<li>提高CPU和I&#x2F;O设备之间并行性</li>
</ul>
</li>
<li>缓冲区的实现<ul>
<li>硬件缓冲<ul>
<li>成本高，只有一些关键部位采用</li>
</ul>
</li>
<li>利用内存<ul>
<li><strong>单缓冲</strong><ul>
<li>每当用户进程发出一个I&#x2F;O请求，OS在内存中为之分配一个缓冲区</li>
<li>通常一个缓冲区大小就是一个块</li>
<li>块设备输入时<br><img src="https://shingeki-pic.oss-cn-nanjing.aliyuncs.com/img/20250402111857339.png"><ul>
<li>设从设备将一块数据输入到缓冲区的时间为 $T$</li>
<li>OS将缓冲区中数据传送到工作区的时间为 $M$</li>
<li>CPU对数据处理时间为 $C$</li>
<li>缓冲区装满后才能从缓冲区中取出数据</li>
</ul>
</li>
<li><strong>时间分析</strong><ul>
<li>$T$和 $C$<strong>可以并行</strong>（上一个块的 $C$和下一个块的 $T$）</li>
<li>$T&gt;C$时，CPU处理完一块数据后，暂时不能将下一块数据传到工作区，必须等缓冲区装满数据，再传送下一块，平均处理一块的时间为 $T+M$</li>
<li>$T&lt;C$时，缓冲区装满数据后，必须等CPU处理完上一块数据，才能传送到工作区，平均处理一块的时间为 $C+M$</li>
<li>所以平均处理一块的时间为 $max(C,T)+M$</li>
</ul>
</li>
</ul>
</li>
<li><strong>双缓冲（缓冲对换）</strong><ul>
<li>加快I&#x2F;O，提高设备利用率<br><img src="https://shingeki-pic.oss-cn-nanjing.aliyuncs.com/img/20250402111906146.png"></li>
<li>输入时，先输入到缓冲区1，装满后转向缓冲区2</li>
<li>此时OS可以从缓冲区1里取出数据，CPU开始处理</li>
<li>1中数据处理完后，若2已满，继续从2中取数据处理</li>
<li><strong>时间分析</strong><ul>
<li>$C$、$M$（上一块的）可以和$T$（下一块的）并行</li>
<li>$T&gt;C+M$时，设备输入的时间比传送和处理的时间长，设备可以连续输入<ul>
<li>分析：某时刻1空，2满，2传送数据，1装入数据。传输并处理的时间为 $C+M$，但此时1未满，必须等1装满。总时间为 $T$</li>
</ul>
</li>
<li>$T&lt;C+M$时，设备输入的时间比数据传送和处理的时间少，CPU不必等待设备输入<ul>
<li>分析：某时刻1空，2满，2传送数据，1装入数据。1装满用时 $T$，必须等2中数据传送、处理完之后，才能开始传送。总时间为 $C+M$</li>
</ul>
</li>
<li>每块平均时间 $max(C+M,T)$</li>
</ul>
</li>
<li>若两台机器之间仅配置单缓冲，则任意时刻都只能实现单方向数据传输<ul>
<li>为了实现双向数据传输，必须在两台机器中都设置两个缓冲区，一个用作发送缓冲区，一个用作接收缓冲区<br><img src="https://shingeki-pic.oss-cn-nanjing.aliyuncs.com/img/20250402111917342.png"></li>
</ul>
</li>
</ul>
</li>
<li><strong>循环缓冲</strong><ul>
<li>双缓冲机制中，输入输出速度基本匹配的时候，能取得较好效果</li>
<li>输入输出差别大时，引入多缓冲机制，<strong>让多个缓冲区组成循环缓冲区</strong></li>
<li>包含多个大小相等的缓冲区，每个缓冲区有一个指针指向下个缓冲区，链接成循环队列</li>
<li>循环缓冲中还需要设置in out两个指针<ul>
<li>in指向第一个可以输入数据的空缓冲区</li>
<li>out指向第一个可以提取数据的满缓冲区</li>
<li>输入&#x2F;输出时，in out指针沿链接方向移动</li>
</ul>
</li>
</ul>
</li>
<li><strong>缓冲池</strong><ul>
<li>缓冲区是一块内存空间，缓冲池是包含一个用于管理自身的数据结构和一组操作函数的管理机制</li>
<li>用于管理多个缓冲区</li>
<li>可供多个进程共享</li>
<li>缓冲池由多个系统公用的缓冲区组成<ul>
<li>缓冲区中有 空缓冲队列 输入队列 输出队列<ul>
<li>这些队列都是对应类型的缓冲区链接成的</li>
</ul>
</li>
<li>4种工作缓冲区<ul>
<li>收容输入数据的hin</li>
<li>提取输入数据的sin</li>
<li>收容输出的hout</li>
<li>提取输出的sout</li>
</ul>
</li>
<li>工作时从对应的队列队首取出缓冲区，操作完后插入相应的其他队列<br><img src="https://shingeki-pic.oss-cn-nanjing.aliyuncs.com/img/20250402111923373.png"></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>高速缓存和缓冲区对比</strong></p>
<ul>
<li>相同点<ul>
<li>两者都介于高速低速设备之间</li>
</ul>
</li>
<li>不同点<ul>
<li>存放数据<ul>
<li>高速缓存存放低速设备上某些数据的复制</li>
<li>缓冲区存放高速低速之间传递的数据</li>
</ul>
</li>
<li>目的<ul>
<li>高速缓存存放高速设备经常要访问的数据</li>
<li>高速设备和低速设备的通信都要经过缓冲区，不存在直接访问</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="设备分配与回收"><a href="#设备分配与回收" class="headerlink" title="设备分配与回收"></a>设备分配与回收</h3><ul>
<li><p>设备分配是指根据用户的I&#x2F;O请求分配所需设备</p>
</li>
<li><p><strong>相关数据结构</strong></p>
<ul>
<li>系统中有多个通道，每个通道连接多个控制器，每个控制器连接多个物理设备，数据结构要求体现这种关系</li>
<li><strong>设备控制表（DCT）</strong><ul>
<li>系统为每个设备配置一个DCT，表项就是设备各个属性</li>
<li>应该包含 设备类型 设备标识符（物理设备名） 设备状态 指向控制器表的指针等</li>
</ul>
</li>
<li><strong>控制器控制表（COCT）</strong><ul>
<li>每个设备控制器对应一个COCT</li>
<li>表项有 与控制器连接的通道表指针</li>
</ul>
</li>
<li><strong>通道控制表（CHCT）</strong><ul>
<li>每个通道有一个CHCT</li>
<li>通过表项 与通道连接的控制器表首址 可以找到该通道管理的所有控制器的信息</li>
</ul>
</li>
<li><strong>系统设备表（SDT）</strong> <ul>
<li>整个系统只有一个SDT</li>
<li>记录系统中所有物理设备的情况</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>设备分配时应该考虑的因素（23）</strong></p>
<ul>
<li>设备固有属性<ul>
<li>独占设备：分配给进程后，进程独占</li>
<li>共享设备：可以同时分配给多个，需要合理调度</li>
<li>虚拟设备：可共享，也可以同时分配给多个</li>
</ul>
</li>
<li>设备分配算法<ul>
<li>FCFS算法，根据进程提出请求的先后次序 排成队列</li>
<li>最高优先级优先</li>
</ul>
</li>
<li>安全性（防止死锁）<ul>
<li>安全分配方式<ul>
<li>进程发出I&#x2F;O请求后就进入阻塞态，直到I&#x2F;O操作完成再唤醒</li>
<li>设备分配安全</li>
<li>但CPU和I&#x2F;O设备串行工作</li>
</ul>
</li>
<li>不安全分配方式<ul>
<li>进程发出I&#x2F;O请求后仍然继续运行，需要时可能还会继续发出请求</li>
<li>仅当所请求的设备被其他进程占用，才进入阻塞态</li>
<li>一个进程可以同时操作多个设备</li>
<li>但可能死锁</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>设备分配的步骤</strong></p>
<ul>
<li>以<strong>独占设备</strong>为例</li>
<li><strong>分配设备</strong><ul>
<li>根据I&#x2F;O请求中的物理设备名，查找SDT，找到设备的DCT，获取设备状态<ul>
<li>若忙，将进程PCB挂到设备等待队列中</li>
<li>若不忙，根据一定策略分配</li>
</ul>
</li>
</ul>
</li>
<li><strong>分配控制器</strong><ul>
<li>设备分配后，根据DCT找到COCT，查询控制器状态<ul>
<li>若忙，将进程PCB挂到控制器等待队列中</li>
<li>若不忙，将控制器分配给该进程</li>
</ul>
</li>
</ul>
</li>
<li><strong>分配通道</strong><ul>
<li>控制器分配后，根据COCT找到CHCT，查询通道状态<ul>
<li>若忙，将进程PCB挂到通道等待队列</li>
<li>若不忙，将通道分配给进程</li>
</ul>
</li>
</ul>
</li>
<li>三者都分配成功后，设备分配才成功。之后可以启动设备传送数据</li>
<li>以上的设备分配过程使用物理设备名，<strong>不具有设备无关性</strong>。<ul>
<li>使用逻辑设备名时，系统从SDT中寻找第一个该类设备的DCT</li>
<li>若忙，则依次寻找该类设备</li>
<li>若都忙，再挂入等待队列</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>逻辑设备名到物理设备名的映射（09）</strong></p>
<ul>
<li>在系统中配备一张逻辑设备表，将逻辑设备名映射为物理设备名</li>
<li><strong>逻辑设备表（LUT）</strong> 的每个表项包含逻辑设备名 物理设备名 设备驱动的入口地址</li>
<li>进程用逻辑设备名请求设备的时候<ul>
<li>系统分配一台相应物理设备</li>
<li>在LUT中建立一个条目，填上相应信息</li>
<li>以后进程再利用该逻辑设备名请求I&#x2F;O操作时，系统查找LUT寻找对应的物理设备和驱动</li>
</ul>
</li>
<li>LUT的两种方式<ul>
<li>整个系统只有一张<ul>
<li>所有用户不能使用相同逻辑设备名</li>
<li>适用于单用户系统</li>
</ul>
</li>
<li>每个用户一张</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="SPOOLing技术（假脱机技术）（16）"><a href="#SPOOLing技术（假脱机技术）（16）" class="headerlink" title="SPOOLing技术（假脱机技术）（16）"></a>SPOOLing技术（假脱机技术）（16）</h3><ul>
<li><p>为了缓和CPU的高速性和I&#x2F;O设备低速性的矛盾，引入假脱机技术</p>
<ul>
<li>GPT: <strong>脱机输入&#x2F;输出</strong>是指设备可以独立完成数据的输入或输出，而不需要一直依赖中央处理器（CPU）的控制。</li>
<li><strong>SPOOLing</strong> 模拟了这种脱机的方式，但实际上，设备并未真正脱离计算机，而是通过<strong>缓冲区</strong>或<strong>中间存储介质</strong>（通常是磁盘或内存）实现的。这就是为什么叫“假脱机”：系统中的外设看起来像是“脱机”处理输入&#x2F;输出任务，但实际上数据仍然通过计算机的调度进行管理。</li>
</ul>
</li>
<li><p>将独占设备改造成共享设备</p>
<ul>
<li>比如让多个进程认为自己占有打印机</li>
</ul>
</li>
</ul>
<p><img src="https://shingeki-pic.oss-cn-nanjing.aliyuncs.com/img/20250402111931330.png"></p>
<ul>
<li><p><strong>SPOOLing组成</strong></p>
<ul>
<li>输入井和输出井<ul>
<li>在磁盘上开辟出的两个存储区域</li>
<li>输入井模拟脱机输入时的磁盘，收容I&#x2F;O设备输入数据</li>
<li>输出井模拟脱机输出时的磁盘，用于收容用户程序输出数据</li>
<li>一个进程的输入（输出）数据保存为一个文件</li>
<li>所有进程的输入（输出）文件链接成一个队列</li>
</ul>
</li>
<li>输入缓冲区和输出缓冲区<ul>
<li>内存中的两个缓冲区</li>
<li>输入缓冲区暂存输入设备送来的数据，后面传送到输入井</li>
<li>输出缓冲区同理</li>
</ul>
</li>
<li>输入进程和输出进程<ul>
<li>输入进程模拟脱机输入时的外围控制机，将数据从输入设备传送到输入缓冲区，再放到输入井<ul>
<li>GPT: <strong>外围控制机</strong>（Peripheral Control Unit），有时也称为<strong>通道控制器</strong>或<strong>外围处理器</strong>，是一种用于管理输入&#x2F;输出设备操作的专用硬件设备。它的主要功能是负责处理外围设备的输入或输出请求，而无需中央处理器（CPU）直接参与这些操作。</li>
</ul>
</li>
<li>输出进程将数据从内存传送到输出井，输出设备空闲时，将输出井中数据经缓冲区输出到设备</li>
</ul>
</li>
<li>井管理程序<ul>
<li>控制作业和磁盘井之间信息交换</li>
</ul>
</li>
</ul>
</li>
<li><p>以独占设备打印机为例</p>
<ul>
<li>多个用户进程发出打印输出请求时，SPOOLing系统同意它们的请求</li>
<li>假脱机管理进程为每个进程做两项工作<ul>
<li>在磁盘缓冲区为进程申请一个空闲盘块，将要打印的数据送入其中暂存</li>
<li>为进程申请一张空白的用户请求打印表，将用户打印要求填入其中，再将该表挂到假脱机文件队列上</li>
</ul>
</li>
<li>对每个用户进程而言，系统没有真正打印，只是将数据输出到缓冲区。</li>
<li>真正打印是在打印机空闲且打印任务在等待队列的队首</li>
<li>系统为进程分配缓冲区，相当于分配了一个逻辑设备，使每个进程认为自己独占了打印机，实现了共享</li>
</ul>
</li>
<li><p><strong>SPOOLing特点</strong></p>
<ul>
<li>提高I&#x2F;O速度，将对低速I&#x2F;O设备的操作变为对磁盘缓冲区中数据的存取</li>
<li>独占设备改造为共享设备</li>
<li>实现虚拟设备功能，对于每个进程，它们都认为自己独占设备</li>
</ul>
</li>
</ul>
<h3 id="设备驱动程序接口"><a href="#设备驱动程序接口" class="headerlink" title="设备驱动程序接口"></a>设备驱动程序接口</h3><ul>
<li><p>设备驱动程序是I&#x2F;O系统上层与设备控制器之间的通信程序</p>
</li>
<li><p>主要任务是接收上层应用的抽象I&#x2F;O请求 比如read&#x2F;write，转换为具体要求后发给设备控制器</p>
</li>
<li><p>也能将设备控制器发来的信号传给上层应用</p>
</li>
<li><p><strong>应该具有的功能（13 19 23）</strong></p>
<ul>
<li>接收上层软件发来的命令和参数，并转换为设备具体要求</li>
<li>检查用户I&#x2F;O请求合法性</li>
<li>了解设备工作状态</li>
<li>传递设备操作相关参数</li>
<li>设置设备工作方式</li>
<li>发出I&#x2F;O命令<ul>
<li>若设备空闲，立即启动</li>
<li>否则将请求者PCB挂到等待队列</li>
</ul>
</li>
<li>及时响应设备控制器发来的中断请求，调用相应中断处理程序</li>
</ul>
</li>
<li><p><strong>设备驱动程序特点（22）</strong></p>
<ul>
<li>与设备采用的I&#x2F;O控制方式密切相关</li>
<li>与硬件密切相关，对于不同类型设备，应该有不同的驱动</li>
<li>很多驱动的基本部分已经固化在ROM</li>
<li>驱动应该允许同时多次调用执行</li>
</ul>
</li>
</ul>
<h3 id="磁盘和固态硬盘"><a href="#磁盘和固态硬盘" class="headerlink" title="磁盘和固态硬盘"></a>磁盘和固态硬盘</h3><h3 id="磁盘（19）"><a href="#磁盘（19）" class="headerlink" title="磁盘（19）"></a>磁盘（19）</h3><ul>
<li><p>有一个称为磁头的导体线圈存取数据</p>
<ul>
<li>读写期间，磁头固定，磁盘高速旋转</li>
</ul>
</li>
<li><p>磁盘盘面上的数据存在一组同心圆中，称为磁道</p>
<ul>
<li>每个磁道和磁头一样宽</li>
<li>一个盘面有上千个磁道</li>
</ul>
</li>
<li><p>磁道划分为几百个扇区，每个扇区固定存储大小（如1KB）</p>
<ul>
<li>一个扇区称为一个盘块</li>
<li>扇区按照固定圆心角度划分<ul>
<li>每个磁道划分为相同数目的扇区</li>
<li>扇区大小固定，所以密度从最外道向内增加</li>
<li>磁盘存储能力受限于最内道的最大记录密度</li>
<li>现代磁盘为了充分利用外层磁道存储能力<ul>
<li>将盘面分为若干环带，同一环带内的所有磁道具有相同的扇区数</li>
<li>外层环带的磁道比内层扇区更多</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>相邻磁道和扇区通过一定间隙隔开，防止精度错误</p>
</li>
</ul>
<p><img src="https://shingeki-pic.oss-cn-nanjing.aliyuncs.com/img/20250402111939519.png"></p>
<ul>
<li><p>多个盘面堆叠，组成磁盘组</p>
<ul>
<li>每个盘面对应一个磁头，所有磁头固定，与磁盘中心距离相同</li>
<li><strong>所有盘面上相对位置相同的磁道组成柱面（相当于圆柱壁）</strong></li>
</ul>
</li>
<li><p>扇区是磁盘可寻址的最小单位</p>
</li>
<li><p>磁盘上能存储的物理块数目由 扇区数 磁道数 磁盘面数决定</p>
<ul>
<li>这种分割是将磁盘拆分为多个盘 每个盘继续拆分为多个磁道 磁道拆分为扇区</li>
</ul>
</li>
<li><p><strong>磁盘地址用 柱面号 盘面号 扇区号 表示</strong></p>
<ul>
<li>这种分割将磁盘纵向拆分为多个柱面，每个柱面按盘面数横向拆分为多个磁道，磁道拆分为扇区</li>
</ul>
</li>
</ul>
<h3 id="磁盘的管理"><a href="#磁盘的管理" class="headerlink" title="磁盘的管理"></a>磁盘的管理</h3><ul>
<li><p><strong>磁盘初始化</strong></p>
<ul>
<li>低级格式化（物理格式化）<ul>
<li>在磁盘可以存储数据之前，必须将它分成扇区，以便磁盘控制器进行读写</li>
<li>每个扇区由头部 数据区域和尾部组成<ul>
<li>头部尾部包含一些磁盘控制器的使用信息<ul>
<li>利用磁道号 磁头号 扇区号标志一个扇区</li>
<li>利用CRC字段对扇区进行校验</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>分区</strong></p>
<ul>
<li>在磁盘存储文件之前，还需要两个步骤<ul>
<li><strong>将磁盘分区</strong><ul>
<li>每个分区由一个或者多个柱面组成</li>
<li>每个分区的起始扇区和大小都记录在磁盘主引导记录的分区表中</li>
</ul>
</li>
<li><strong>对物理分区逻辑格式化（高级格式化）（17 21）</strong><ul>
<li>将初始文件系统数据结构存储到磁盘上<ul>
<li>包括空闲空间和已分配空间 初始为空的目录</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>扇区单位太小，OS将多个相邻扇区组合在一起，形成一簇（Linux中称为块）<ul>
<li>一簇只能存放一个文件的内容，文件所占空间只能是簇的整数倍</li>
<li>0字节的文件也占一簇</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>引导块</strong></p>
<ul>
<li>计算机启动时运行一个初始化程序（自举程序），初始化CPU 寄存器 设备控制器 内存等，然后启动OS<ul>
<li>自举程序需要找到磁盘上的OS内核，加载到内存，并转到起始地址</li>
<li>GPT: 自举的含义：bootstrap，自己拉自己脱离泥沼</li>
</ul>
</li>
<li>自举程序通常存放在ROM中<ul>
<li>为了避免改变自举代码而需要改变ROM硬件的问题<ul>
<li>通常ROM中只保留很小的自举装入程序</li>
<li>完整功能的引导程序保存在磁盘启动块上<ul>
<li>启动块位于磁盘固定位置</li>
</ul>
</li>
</ul>
</li>
<li>引导ROM中的代码指示磁盘控制器将引导块读入内存，然后开始执行<ul>
<li>它可以从非固定的磁盘位置加载整个OS</li>
</ul>
</li>
</ul>
</li>
<li>Windows引导过程<ul>
<li>磁盘分为多个分区，有一个引导分区<ul>
<li>引导分区包含OS和驱动</li>
</ul>
</li>
<li>引导代码存在磁盘0号扇区，称为主引导记录（MBR）<ul>
<li>MBR还包含一个磁盘分区表和一个标志（指示从哪个分区引导系统）</li>
</ul>
</li>
<li>系统找到引导分区时，读取第一个扇区（引导扇区），开始加载各种系统服务</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>坏块</strong></p>
<ul>
<li>简单磁盘的坏块可以手动处理<ul>
<li>比如MS-DOS的逻辑格式化会扫描磁盘检查坏块，在FAT表上标出来</li>
</ul>
</li>
<li>复杂的磁盘中，控制器维护磁盘内坏块列表<ul>
<li>控制器可以采用备用块逻辑地替代坏块</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="磁盘调度算法"><a href="#磁盘调度算法" class="headerlink" title="磁盘调度算法"></a>磁盘调度算法</h3><ul>
<li><p><strong>磁盘存取时间</strong></p>
<ul>
<li>一次磁盘读写的时间由寻道时间、旋转延迟时间、传输时间决定</li>
<li><strong>寻道时间</strong><ul>
<li>活动头磁盘在读写之前，将磁头移动到目的磁道所需时间</li>
<li>m是与磁盘驱动器速度有关的常数 跨越n条磁道，启动磁头臂时间s</li>
<li>$$T_s&#x3D;m×n＋s$$</li>
</ul>
</li>
<li><strong>旋转延迟时间</strong><ul>
<li>磁头定位到要读写的扇区所需时间</li>
<li>设旋转速度为r</li>
<li>$$T_r＝\frac{1}{2r}$$</li>
<li>取了平均值，相当于转一圈所需时间的一半</li>
</ul>
</li>
<li><strong>传输时间</strong><ul>
<li>从磁盘读出或者向磁盘写入数据所需时间</li>
<li>读&#x2F;写字节数b，磁盘旋转速度r，一个磁道上字节数N</li>
<li>$$T_t＝\frac{b}{rN}$$</li>
</ul>
</li>
<li>总时间为上面三者之和</li>
</ul>
</li>
<li><p><strong>磁盘调度算法（09 10 15 18 19 21 24）</strong></p>
<ul>
<li>磁盘存取时间中，寻道时间占比最大，与磁盘调度算法密切相关</li>
<li>调度的主要目标是减少磁盘平均寻道时间</li>
<li><strong>FCFS算法</strong><ul>
<li>根据请求访问磁盘的先后顺序进行调度</li>
</ul>
</li>
<li><strong>最短寻道时间优先（SSTF）算法</strong><ul>
<li>每次选择与当前磁头最近的磁道</li>
<li>可能出现饥饿现象</li>
</ul>
</li>
<li><strong>扫描（SCAN）算法（电梯调度算法）</strong><ul>
<li>防止SSTF中产生的饥饿（磁头在小范围内来回移动，不能到达远处）</li>
<li>规定磁头移动到最外侧时才能向内，移动到最内侧时才能向外</li>
<li>也就是在SSTF的基础上规定了磁头移动的方向</li>
<li>SCAN算法对最近扫描过的区域不公平，访问局部性不如FCFS和SSTF</li>
<li>偏向于处理靠内或者靠外的请求</li>
</ul>
</li>
<li><strong>循环扫描（C-SCAN）算法</strong><ul>
<li>在SCAN算法的基础上<ul>
<li>磁头返回时直接移动到起始端，不服务任何请求</li>
</ul>
</li>
<li>消除对两端磁道请求的不公平</li>
</ul>
</li>
<li><strong>LOOK和C-LOOK</strong><ul>
<li>SCAN和C-SCAN的基础上<ul>
<li>磁头只需要移动到最远端的请求就可以返回，不需要到达磁盘端点</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>减少延迟时间的方法</strong></p>
<ul>
<li>交替编号（扇区）<ul>
<li>磁盘是连续自转设备，磁头读入一个扇区后，需要短暂处理时间，才能读下一个扇区</li>
<li>若逻辑上相邻的块在物理上也相邻，则读入几个连续的逻辑块可能需要很长延迟</li>
<li>所以对一个盘面的扇区交替编号</li>
</ul>
</li>
<li>错位命名（不同盘面的扇区）<ul>
<li>逻辑块在相同柱面上按盘面号连续存放<ul>
<li>0号盘0扇区 0号盘1扇区……0号盘7扇区 1号盘0扇区……的顺序</li>
<li>要读入不同盘面上的连续块，在读完0号盘7扇区后，需要一段处理时间<ul>
<li>此时磁头划过1号盘0扇区并不能读取，与上面同理</li>
</ul>
</li>
</ul>
</li>
<li>所以对不同的盘面错位命名<ul>
<li>也就是相同柱面上不同盘面的<strong>扇区编号错位</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>提高磁盘I&#x2F;O速度的方法（12 18）</strong></p>
<ul>
<li>采用磁盘高速缓存</li>
<li>调整磁盘请求顺序<ul>
<li>即上面的调度算法</li>
</ul>
</li>
<li>提前读<ul>
<li>读磁盘当前块时，将下一磁盘块也读入内存缓冲区</li>
</ul>
</li>
<li>延迟写<ul>
<li>仅在缓冲区首部设置延迟写标志，然后释放此缓冲区并将其链入空闲缓冲区链表尾部</li>
<li>当其他进程申请到此缓冲区的时候，才真正将缓冲区信息写入磁盘块<ul>
<li>GPT: 写入触发条件<ul>
<li>缓冲区达到容量上限</li>
<li>定时触发</li>
<li>系统关机、卸载文件系统</li>
</ul>
</li>
</ul>
</li>
<li>GPT: 允许多个写操作在内存中进行聚合，减少对磁盘的频繁写操作</li>
</ul>
</li>
<li>优化物理块分布<ul>
<li>上面的扇区编号优化</li>
<li>文件采用链接方式和索引方式组织时<ul>
<li>尽量将同一个文件的盘块安排在一个磁道上或者相邻磁道上，减少寻道时间</li>
</ul>
</li>
<li>将若干盘块组成簇，按簇对文件分配，也可以减少磁头平均移动距离</li>
</ul>
</li>
<li>虚拟盘<ul>
<li>用内存空间仿真磁盘，又叫RAM盘</li>
<li>常用于存放临时文件</li>
</ul>
</li>
<li>采用磁盘阵列RAID<ul>
<li>由于可以采用并行交叉存取，因此能大幅提高I&#x2F;O速度</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="固态硬盘（SSD）"><a href="#固态硬盘（SSD）" class="headerlink" title="固态硬盘（SSD）"></a>固态硬盘（SSD）</h3><ul>
<li><p><strong>固态硬盘特性</strong></p>
<ul>
<li>基于闪存技术</li>
<li>由一个或多个闪存芯片和闪存翻译层组成<ul>
<li>闪存芯片代替传统磁盘的机械驱动器</li>
<li>闪存翻译层将来自CPU的逻辑块读、写请求翻译成对底层物理设备的控制信号，相当于磁盘控制器</li>
<li>一个闪存由多个块组成，每块由多个页组成<ul>
<li>数据以页为单位读写</li>
<li>只有一页所属的块整个被擦除后，才能写这一页</li>
<li>某个块多次写后就会损坏</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>磨损均衡</strong></p>
<ul>
<li>闪存擦写寿命有限，且一部分闪存损坏会导致整个SSD的损坏<ul>
<li>所以需要磨损均衡</li>
</ul>
</li>
<li>动态磨损均衡<ul>
<li>写入数据时，自动选择较新的闪存块</li>
</ul>
</li>
<li>静态磨损均衡<ul>
<li>SSD检测并自动进行数据分配，老闪存块承担无须写的存储任务，新闪存块腾出空间</li>
<li>平常读写在新闪存块中</li>
</ul>
</li>
</ul>
</li>
</ul>
</article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a><a class="post-meta__tags" href="/tags/OS/">OS</a><a class="post-meta__tags" href="/tags/%E8%80%83%E7%A0%94/">考研</a><a class="post-meta__tags" href="/tags/I-O%E7%AE%A1%E7%90%86/">I/O管理</a><a class="post-meta__tags" href="/tags/I-O/">I/O</a></div><div class="post-share"><div class="social-share" data-image="https://shingeki-pic.oss-cn-nanjing.aliyuncs.com/img/20250402113113735.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/03/31/OS-learning-3/" title="王道OS看书笔记——文件管理"><img class="cover" src="https://shingeki-pic.oss-cn-nanjing.aliyuncs.com/img/20250402113041743.jpg" onerror="onerror=null;src='https://shingeki-pic.oss-cn-nanjing.aliyuncs.com/img/20250402112720227.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">王道OS看书笔记——文件管理</div></div><div class="info-2"><div class="info-item-1">本文为我考研期间看王道书时写的飞书笔记，根据各知识点的逻辑关系进行整理，添加了一点自己的理解，内容不如王道书全。</div></div></div></a><a class="pagination-related" href="/2025/04/02/butterfly-learning/" title="hexo及butterfly主题使用踩坑记录"><img class="cover" src="https://shingeki-pic.oss-cn-nanjing.aliyuncs.com/img/20250402112813911.jpg" onerror="onerror=null;src='https://shingeki-pic.oss-cn-nanjing.aliyuncs.com/img/20250402112720227.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">hexo及butterfly主题使用踩坑记录</div></div><div class="info-2"><div class="info-item-1">记录hexo和butterfly主题使用中出现的问题及解决方法</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2025/03/30/OS-learning-1/" title="王道OS看书笔记——进程与线程"><img class="cover" src="https://shingeki-pic.oss-cn-nanjing.aliyuncs.com/img/20250402112940979.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-03-30</div><div class="info-item-2">王道OS看书笔记——进程与线程</div></div><div class="info-2"><div class="info-item-1">本文为我考研期间看王道书时写的飞书笔记，根据各知识点的逻辑关系进行整理，添加了一点自己的理解，内容不如王道书全。</div></div></div></a><a class="pagination-related" href="/2025/03/30/OS-learning-2/" title="王道OS看书笔记——内存管理"><img class="cover" src="https://shingeki-pic.oss-cn-nanjing.aliyuncs.com/img/20250402113012234.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-03-30</div><div class="info-item-2">王道OS看书笔记——内存管理</div></div><div class="info-2"><div class="info-item-1">本文为我考研期间看王道书时写的飞书笔记，根据各知识点的逻辑关系进行整理，添加了一点自己的理解，内容不如王道书全。</div></div></div></a><a class="pagination-related" href="/2025/03/31/OS-learning-3/" title="王道OS看书笔记——文件管理"><img class="cover" src="https://shingeki-pic.oss-cn-nanjing.aliyuncs.com/img/20250402113041743.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-03-31</div><div class="info-item-2">王道OS看书笔记——文件管理</div></div><div class="info-2"><div class="info-item-1">本文为我考研期间看王道书时写的飞书笔记，根据各知识点的逻辑关系进行整理，添加了一点自己的理解，内容不如王道书全。</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="https://shingeki-pic.oss-cn-nanjing.aliyuncs.com/img/20250402112624099.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">shingeki</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">7</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">31</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/youzhoujiMrLiu"><i class="fab fa-github"></i><span>我的Github主页</span></a></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#I-O%E7%AE%A1%E7%90%86%E6%A6%82%E8%BF%B0"><span class="toc-number">1.</span> <span class="toc-text">I&#x2F;O管理概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#I-O%E8%AE%BE%E5%A4%87"><span class="toc-number">1.1.</span> <span class="toc-text">I&#x2F;O设备</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#I-O%E6%8E%A7%E5%88%B6%E6%96%B9%E5%BC%8F"><span class="toc-number">1.2.</span> <span class="toc-text">I&#x2F;O控制方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#I-O%E8%BD%AF%E4%BB%B6%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84"><span class="toc-number">1.3.</span> <span class="toc-text">I&#x2F;O软件层次结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8FI-O%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.4.</span> <span class="toc-text">应用程序I&#x2F;O接口</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BE%E5%A4%87%E7%8B%AC%E7%AB%8B%E6%80%A7%E8%BD%AF%E4%BB%B6"><span class="toc-number">2.</span> <span class="toc-text">设备独立性软件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98%E5%92%8C%E7%BC%93%E5%86%B2%E5%8C%BA"><span class="toc-number">2.1.</span> <span class="toc-text">高速缓存和缓冲区</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E5%A4%87%E5%88%86%E9%85%8D%E4%B8%8E%E5%9B%9E%E6%94%B6"><span class="toc-number">2.2.</span> <span class="toc-text">设备分配与回收</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SPOOLing%E6%8A%80%E6%9C%AF%EF%BC%88%E5%81%87%E8%84%B1%E6%9C%BA%E6%8A%80%E6%9C%AF%EF%BC%89%EF%BC%8816%EF%BC%89"><span class="toc-number">2.3.</span> <span class="toc-text">SPOOLing技术（假脱机技术）（16）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F%E6%8E%A5%E5%8F%A3"><span class="toc-number">2.4.</span> <span class="toc-text">设备驱动程序接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A3%81%E7%9B%98%E5%92%8C%E5%9B%BA%E6%80%81%E7%A1%AC%E7%9B%98"><span class="toc-number">2.5.</span> <span class="toc-text">磁盘和固态硬盘</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A3%81%E7%9B%98%EF%BC%8819%EF%BC%89"><span class="toc-number">2.6.</span> <span class="toc-text">磁盘（19）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A3%81%E7%9B%98%E7%9A%84%E7%AE%A1%E7%90%86"><span class="toc-number">2.7.</span> <span class="toc-text">磁盘的管理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A3%81%E7%9B%98%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="toc-number">2.8.</span> <span class="toc-text">磁盘调度算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%BA%E6%80%81%E7%A1%AC%E7%9B%98%EF%BC%88SSD%EF%BC%89"><span class="toc-number">2.9.</span> <span class="toc-text">固态硬盘（SSD）</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/04/03/software-safety-reports/" title="软件安全课程报告汇总"><img src="https://shingeki-pic.oss-cn-nanjing.aliyuncs.com/img/20250403232317140.jpg" onerror="this.onerror=null;this.src='https://shingeki-pic.oss-cn-nanjing.aliyuncs.com/img/20250402112720227.jpg'" alt="软件安全课程报告汇总"/></a><div class="content"><a class="title" href="/2025/04/03/software-safety-reports/" title="软件安全课程报告汇总">软件安全课程报告汇总</a><time datetime="2025-04-03T15:14:39.000Z" title="发表于 2025-04-03 23:14:39">2025-04-03</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/04/03/graduate-proj-exp/" title="毕设前端经验总结"><img src="https://shingeki-pic.oss-cn-nanjing.aliyuncs.com/img/20250403202302474.jpg" onerror="this.onerror=null;this.src='https://shingeki-pic.oss-cn-nanjing.aliyuncs.com/img/20250402112720227.jpg'" alt="毕设前端经验总结"/></a><div class="content"><a class="title" href="/2025/04/03/graduate-proj-exp/" title="毕设前端经验总结">毕设前端经验总结</a><time datetime="2025-04-03T12:17:13.000Z" title="发表于 2025-04-03 20:17:13">2025-04-03</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/04/02/butterfly-learning/" title="hexo及butterfly主题使用踩坑记录"><img src="https://shingeki-pic.oss-cn-nanjing.aliyuncs.com/img/20250402112813911.jpg" onerror="this.onerror=null;this.src='https://shingeki-pic.oss-cn-nanjing.aliyuncs.com/img/20250402112720227.jpg'" alt="hexo及butterfly主题使用踩坑记录"/></a><div class="content"><a class="title" href="/2025/04/02/butterfly-learning/" title="hexo及butterfly主题使用踩坑记录">hexo及butterfly主题使用踩坑记录</a><time datetime="2025-04-01T16:09:58.000Z" title="发表于 2025-04-02 00:09:58">2025-04-02</time></div></div></div></div></div></div></main><footer id="footer" style="background: transparent;"><div id="footer-wrap"><div class="copyright">&copy;2025 By shingeki</div><div class="footer_custom_text">Powered by Hexo & Butterfly.</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>(() => {
  const loadMathjax = () => {
    if (!window.MathJax) {
      window.MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          tags: 'none',
        },
        chtml: {
          scale: 1.1
        },
        options: {
          enableMenu: true,
          renderActions: {
            findScript: [10, doc => {
              for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
                const display = !!node.type.match(/; *mode=display/)
                const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
                const text = document.createTextNode('')
                node.parentNode.replaceChild(text, node)
                math.start = {node: text, delim: '', n: 0}
                math.end = {node: text, delim: '', n: 0}
                doc.math.push(math)
              }
            }, '']
          }
        }
      }

      const script = document.createElement('script')
      script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
      script.id = 'MathJax-script'
      script.async = true
      document.head.appendChild(script)
    } else {
      MathJax.startup.document.state(0)
      MathJax.texReset()
      MathJax.typesetPromise()
    }
  }

  btf.addGlobalFn('encrypt', loadMathjax, 'mathjax')
  window.pjax ? loadMathjax() : window.addEventListener('load', loadMathjax)
})()</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>